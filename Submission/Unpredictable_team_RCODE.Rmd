# -*- coding: utf-8 -*-
"""Hackathon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nl5VOvKK5XXwcdoPKKhB_zd_2q2HZA_7
"""


#  ---------------------------------------------------
# | Collapse — Alt+L ( Cmd+Option+L on Mac)           |
# | Expand — Shift+Alt+L ( Cmd+Shift+Option+L on Mac) |
# | Collapse All — Alt+O ( Cmd+Option+O on Mac)       |
#  ---------------------------------------------------
# PATH
# Enter Your Path for the Excel File here:
```{r}
# Path for "MASA HACKATHON EXCEL.xlsx"
General <- "/Users/peyton/Downloads/Properity/Unpredictable Team_FinalsDataset.xlsx"
```

# --
# DATA
# Pre: Load Data
```{r}
library(readxl)

claim <- read_excel(General,sheet="Claim")
gprem <- read_excel(General,sheet="Gross Prem (LR)")
fprem <- read_excel(General,sheet="Fac Prem (LR)")

head(claim)
```

# Pre: Data Cleaning
```{r}
# install.packages("tidyr")
library(tidyr)
claim <- claim[rowSums(is.na(claim))!=ncol(claim),]
print(nrow(claim))
claim <- subset(claim,
                       !is.na(HAZARD_LEVEL) & !is.na(OCCUPANCY_TYPE) & !is.na(SEGMENT) &
                         HAZARD_LEVEL != "" & OCCUPANCY_TYPE != "" & SEGMENT != ""
                         & 'Exact Premium' != "#CALC!")

print(nrow(claim))
print(claim[115,grep("OCCUPANCY_TYPE",colnames(claim))])

claim <- claim[,0:18]
claim$POLICY_COMMENCE_DT = as.Date(claim$POLICY_COMMENCE_DT,"%Y/%m/%d",tz="UTC")
claim$POLICY_EXPIRY_DT = as.Date(claim$POLICY_EXPIRY_DT,"%Y/%m/%d",tz="UTC")
claim$CLAIM_OCCURRENCE_DT = as.Date(claim$CLAIM_OCCURRENCE_DT,"%Y/%m/%d",tz="UTC")
head(claim)

claim <- claim[order(claim$CLAIM_OCCURRENCE_DT,decreasing=FALSE),]

# TO CROSS CHECK:
# claim[249:260,]
# print(claim$POLICY_COMMENCE_DT)
# colnames(claim)
# sum(as.numeric(gsub(",","",claim$'Exact Premium')))
# sum(as.numeric(gsub(",","",claim$GROSS_INCURRED)))
```






# Fin: Load Data
```{r}
library(readxl)
motor_claim <- read_excel(General,sheet="MClaim")
head(motor_claim,2)
```
# Fin: Data Cleaning
```{r}
motor_claim <- motor_claim[rowSums(is.na(motor_claim))!=ncol(motor_claim),]
motor_claim$POLICY_COMMENCE_DT = as.Date(motor_claim$POLICY_COMMENCE_DT,"%Y/%m/%d",tz="UTC")
motor_claim$POLICY_EXPIRY_DT = as.Date(motor_claim$POLICY_EXPIRY_DT,"%Y/%m/%d",tz="UTC")
motor_claim$CLAIM_OCCURRENCE_DT = as.Date(motor_claim$CLAIM_OCCURRENCE_DT,"%Y/%m/%d",tz="UTC")
motor_claim <- motor_claim[order(motor_claim$CLAIM_OCCURRENCE_DT,decreasing=FALSE),]
```

# ===========================
# THEORY
# Fac
```{r}
claim$after_fac_incurred = claim$GROSS_INCURRED-claim$FAC_INCURRED

prem <- data.frame(year=c(2019,2020,2021,2022,2023))
for (i in unique(gprem$`Commence Year`)){
  # print(sum(gprem[gprem$`Commence Year`==i,"sum"]))
  prem[prem$year==i,"gprem"]=sum(gprem[gprem$`Commence Year`==i,"sum"])
}

for (i in unique(fprem$`Year`)){
  # print(sum(gprem[gprem$`Commence Year`==i,"sum"]))
  prem[prem$year==i,"fprem"]=sum(fprem[fprem$`Year`==i,"sum"])
}

prem$after_fac = prem$gprem-prem$fprem

prem
```

# --
# Treaty Parameter Tuning
```{r}
#Define Variables for treaty
Retention=30000000
noline = 9
Surplus= noline*Retention
Capacity= Retention + Surplus
```

# TREATY Retention, Ceded amount, Exceed Treaty
```{r}

#RETENTION
# calculate facultative ratio
claim$Facultative_Ratio <- (claim$after_fac_incurred / claim$GROSS_INCURRED)

# calculate gross_sum_insurred after facultative
claim$Other_Reinsurance <- claim$Facultative_Ratio * claim$GROSS_SUM_INSURED

# Calculate Retention Ratio
Retention_Ratio <- ifelse(
  (Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance) >= 1,
  1,
  Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance
)

# Add a new column named "Retention Ratio" to the claim dataframe
claim$Retention_Ratio <- Retention_Ratio

# calculate the Retention_sum insured
claim$Retention_sum_insured<-claim$Other_Reinsurance*claim$Retention_Ratio

# calculate the Retention_loss
claim$Retention_loss<-claim$after_fac_incurred*claim$Retention_Ratio



#CEDED AMOUNT
#calculate ceded amount ratio
claim$Ceded_Amount_Ratio<- 1-claim$Retention_Ratio

#calculate ceded amount_sum insured
claim$Ceded_Amount_sum_insured<- claim$Other_Reinsurance*claim$Ceded_Amount_Ratio

#calculate ceded amount loss
claim$Ceded_Amount_loss<- claim$after_fac_incurred*claim$Ceded_Amount_Ratio



#EXCEED TREATY LIMIT
claim$Exceed_treaty_limit <- ifelse(claim$Other_Reinsurance > Capacity, claim$Other_Reinsurance - Capacity, 0)

#ratio of exceed treaty limit in retention
claim$Exceed_treaty_limit_ratio <- claim$Exceed_treaty_limit/claim$Retention_sum_insured

#Exceed SUM_INCURRED
claim$Exceed_treaty_limit_sum_incurred <- claim$Exceed_treaty_limit_ratio*claim$after_fac_incurred

head(claim,10)
```

# Treaty Calculation
```{r}
# install.packages("dplyr")
# Load the dplyr package
library(dplyr)

Treaty <- function(year){
  claim2019 <- claim[claim$`Min Year` == year, ]
  
  # Group by EVENT_CODE and summarize other columns by sum
  claim2019_combined <- claim2019 %>%
    group_by(EVENT_CODE) %>%
    summarise(
      GROSS_SUM_INSURED = sum(GROSS_SUM_INSURED, na.rm = TRUE),
      Other_Reinsurance = sum(`Other_Reinsurance`, na.rm = TRUE),  # Corrected column name
      GROSS_INCURRED = sum(GROSS_INCURRED, na.rm = TRUE),
      after_fac_incurred = sum(after_fac_incurred, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Convert to dataframe
  claim2019_df <- as.data.frame(claim2019_combined)
  
  # Calculate facultative ratio
  claim2019_df$Facultative_Ratio <- (claim2019_df$after_fac_incurred / claim2019_df$GROSS_INCURRED)
  
  # Calculate gross_sum_insured after facultative
  claim2019_df$Other_Reinsurance <- claim2019_df$Facultative_Ratio * claim2019_df$GROSS_SUM_INSURED
  
  # Calculate Retention Ratio
  Retention_Ratio <- ifelse(
    (Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance) >= 1,
    1,
    Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance
  )
  
  # Add a new column named "Retention Ratio" to the claim2019_df dataframe
  claim2019_df$Retention_Ratio <- Retention_Ratio
  
  # Calculate the Retention_sum_insured
  claim2019_df$Retention_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Retention_Ratio
  
  # Calculate the Retention_loss
  claim2019_df$Retention_loss <- claim2019_df$after_fac_incurred * claim2019_df$Retention_Ratio
  
  # Calculate ceded amount ratio
  claim2019_df$Ceded_Amount_Ratio <- 1 - claim2019_df$Retention_Ratio
  
  # Calculate ceded amount_sum insured
  claim2019_df$Ceded_Amount_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Ceded_Amount_Ratio
  
  # Calculate ceded amount loss
  claim2019_df$Ceded_Amount_loss <- claim2019_df$after_fac_incurred * claim2019_df$Ceded_Amount_Ratio
  
  # Calculate Exceed Treaty Limit
  claim2019_df$Exceed_treaty_limit <- ifelse(claim2019_df$Other_Reinsurance > Capacity, claim2019_df$Other_Reinsurance - Capacity, 0)
  
  # Calculate ratio of exceed treaty limit in retention
  claim2019_df$Exceed_treaty_limit_ratio <- claim2019_df$Exceed_treaty_limit / claim2019_df$Retention_sum_insured
  
  # Calculate Exceed SUM_INCURRED
  claim2019_df$Exceed_treaty_limit_sum_incurred <- claim2019_df$Exceed_treaty_limit_ratio * claim2019_df$after_fac_incurred
  
  # Filter the dataframe for Event codes E001, E002, and E006
  filtered_df2019 <- claim2019_df[claim2019_df$EVENT_CODE %in% unique(claim2019$EVENT_CODE)[!is.na(unique(claim2019$EVENT_CODE))], ]
  
  for (i in 1:length(filtered_df2019$EVENT_CODE)){
    filtered_df2019$Date[i] = claim[which(claim$EVENT_CODE==filtered_df2019$EVENT_CODE[i]),"CLAIM_OCCURRENCE_DT"][[1]][1]
    filtered_df2019$`Claim Year`[i] = year
  }
  colnames(filtered_df2019)[16] = "Date"
  return(filtered_df2019)
}

NaEC = claim[is.na(claim$EVENT_CODE),][,c(11,16,21,14,19,20,22,23,24,25,26,27,28,29,30,4,5)]
colnames(NaEC)[16] = "Date"

TA = data.frame()
Year = c(2019,2020,2021,2022,2023)
for (i in 1:5){
  ans = Treaty(Year[i])
  TA = rbind(TA,ans)
}
GEC = rbind(TA,NaEC)
GEC
# TA
# GEC[which(NaEC$EVENT_CODE=="E006"),]
# GEC
```

# Treaty Premium
```{r}
sum_insured = c(0,100001,250001,500001,750001,1000001,2500001,5000001,7500001,10000001,12000001,14000001,16000001,18000001,20000001,25000001,30000001,40000001,50000001,70000001,100000001,200000001,300000001,400000001,500000001,1000000001)
prem_avr = c(50000.5,175000.5,375000.5,625000.5,875000.5,1750000.5,3750001,6250001,8750001,11000001,13000001,15000001,17000001,19000001,22500001,27500001,35000001,45000001,60000001,85000001,150000001,250000001,350000001,450000001,750000001,1000000001)
prem_data = data.frame(sum_insured=sum_insured,prem_avr=prem_avr,retention_ratio=rep(26,1))

retention_ratio <- function(prem){
  if((Retention/prem+max(0,(prem-Capacity)/prem))>=1){
    return (1)
  }else{
    return(Retention/prem+max(0,(prem-Capacity)/prem))
  }
}

index = 1
for (i in prem_data$prem_avr){
  prem_data[index,3] = retention_ratio(i)
  index = index+1
}
# nrow(prem_data)
print(prem_data[,3])

retention_prem = gprem
retention_prem[,28] = retention_prem[,28]-fprem[,28]
retention_prem[,29] = retention_prem[,29]-fprem[,29]
retention_prem[,30] = retention_prem[,30]-fprem[,30]

# print(retention_prem[,9])
# print(prem_data[25,3])

index = 1
for (i in colnames(retention_prem)[5:30]){
  for (j in 1:nrow(retention_prem[,index+4])){
    retention_prem[j,index+4] = retention_prem[j,index+4]*prem_data[index,3]
    # print(j)
  }
  # print("out")
  index = index +1
}
# print(retention_prem[,29])

for (i in 1:nrow(retention_prem)){
  retention_prem[i,"sum"]= sum(retention_prem[i,5:30])
}

head(retention_prem,5)

gnpiT = data.frame(Year=c(2019,2020,2021,2022,2023))
index = 1
for (i in gnpiT[,1]){
  gnpiT$sumGNPI[index] = sum(retention_prem[retention_prem$`Commence Year`==i,'sum'])
  index = index +1
}
index = 1
for (i in gnpiT[,1]){
  gnpiT$sumGprem[index] = sum(gprem[gprem$`Commence Year`==i,'sum'])
  index = index +1
}
index = 1
for (i in gnpiT[,1]){
  gnpiT$sumFprem[index] = sum(fprem[fprem$`Year`==i,'sum'])
  index = index +1
}

print(gnpiT)
```

# --
# XOL Parameter Tuning
```{r}
layers_info <- data.frame(
  Layers = c("NonMarineLayer1", "NonMarineLayer2", "WholeAccLayer1", "WholeAccLayer2", "WholeAccLayer3"),
  Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
  Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
  Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
  Reinst = c(3,2,2,1,1)
)

Flood_Rate = 1.2
no.layer = 5

gnpi <- data.frame(
  Year = c(2019,2020,2021,2022,2023),
  GNPI = gnpiT$sumGNPI
)
gnpi
```

# XOL Calculation
```{r}
GECK <- GEC[order(GEC$Date,decreasing=FALSE),]
Result <- data.frame("Year","TotalD","TotalLR","TotalRPrem","TotalPrem")

for (i in 1:nrow(GECK)){
  if(GECK$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")){
    GECK$Type[i]="Flood"
  }else{
    GECK$Type[i]="Normal"
  }
}

for (i in 1:5){
  year <- gnpi$Year[i]
  gnpi_year <- gnpi$GNPI[i]
  
  # Group as year
  GEC_Year = GECK[GECK$`Claim Year`==year,]
  colnames(GEC_Year)[15] = "Loss"
  GEC_Year = GEC_Year[GEC_Year$Loss>layers_info$Deductible[1],]
  
  # If that year don't have, then skip
  if(nrow(GEC_Year)==0){
    total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
    total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
    total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
    total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
    
    Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
    next
  }
  
  # RUN every claim
  for(k in 1:nrow(GEC_Year)){
    loss = GEC_Year$Loss[k]
    
    #NML1
    if(loss<=layers_info$Deductible[1]){
      GEC_Year$NML1[k]=loss
    }else{
      GEC_Year$NML1[k]=layers_info$Deductible[1]
    }
    
    #LAR NML1
    GEC_Year$LARNML1[k] = min(min(loss-GEC_Year$NML1[k],layers_info$Limit[1]),layers_info$Limit[1]*(layers_info$Reinst[1]+1))
    
    #Cover Remaining NML1
    GEC_Year$CoverNML1[k] = layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$LARNML1[k]
    
    
    #Reinstated Premium 1
    if(GEC_Year$CoverNML1[k]<layers_info$Limit[1]){
      GEC_Year$PremNML1[k]= 0
    }else{
      if(GEC_Year$Type[k]=="Flood"){
       GEC_Year$PremNML1[k]= Flood_Rate*layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
      }else{
        GEC_Year$PremNML1[k]= layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
      }
    }
    
    #NML2
    if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]<=layers_info$Deductible[2]){
      GEC_Year$NML2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]
    }else{
      GEC_Year$NML2[k]=layers_info$Deductible[2]
    }

    #LAR NML2
    GEC_Year$LARNML2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k],layers_info$Limit[2]),layers_info$Limit[2]*(layers_info$Reinst[2]+1))

    #Cover Remaining NML2
    GEC_Year$CoverNML2[k] = layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$LARNML2[k]

    #Reinstated Premium 2
    if(GEC_Year$CoverNML2[k]<layers_info$Limit[2]){
      GEC_Year$PremNML2[k]= 0
    }else{
      if(GEC_Year$Type[k]=="Flood"){
       GEC_Year$PremNML2[k]= Flood_Rate*layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
      }else{
        GEC_Year$PremNML2[k]= layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
      }
    }
    
    sym = 3
    
    #WAL1
    if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]<=layers_info$Deductible[sym]){
      GEC_Year$WAL1[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]
    }else{
      GEC_Year$WAL1[k]=layers_info$Deductible[sym]
    }

    #LAR WAL1
    GEC_Year$LARWAL1[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k],layers_info$Limit[sym]),layers_info$Limit[sym]*(layers_info$Reinst[sym]+1))

    #Cover Remaining WAL1
    GEC_Year$CoverWAL1[k] = layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$LARWAL1[k]

    #Reinstated Premium 2
    if(GEC_Year$CoverWAL1[k]<layers_info$Limit[sym]){
      GEC_Year$PremWAL1[k]= 0
    }else{
      if(GEC_Year$Type[k]=="Flood"){
       GEC_Year$PremWAL1[k]= Flood_Rate*layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
      }else{
        GEC_Year$PremWAL1[k]= layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
      }
    }
    
    
    sym2 = 4
    #WAL1
    if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]<=layers_info$Deductible[sym2]){
      GEC_Year$WAL2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]
    }else{
      GEC_Year$WAL2[k]=layers_info$Deductible[sym2]
    }
    
    #LAR WAL2
    GEC_Year$LARWAL2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))

    #Cover Remaining WAL2
    GEC_Year$CoverWAL2[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL2[k]

    #Reinstated Premium 2
    if(GEC_Year$CoverWAL2[k]<layers_info$Limit[sym2]){
      GEC_Year$PremWAL2[k]= 0
    }else{
      if(GEC_Year$Type[k]=="Flood"){
       GEC_Year$PremWAL2[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
      }else{
        GEC_Year$PremWAL2[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
      }
    }
    
    sym2 = 5
    #WAL1
    if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]<=layers_info$Deductible[sym2]){
      GEC_Year$WAL3[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]
    }else{
      GEC_Year$WAL3[k]=layers_info$Deductible[sym2]
    }
    
    #LAR wal3
    GEC_Year$LARWAL3[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]-GEC_Year$WAL3[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))

    #Cover Remaining WAL2
    GEC_Year$CoverWAL3[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL3[k]

    #Reinstated Premium 2
    if(GEC_Year$CoverWAL3[k]<layers_info$Limit[sym2]){
      GEC_Year$PremWAL3[k]= 0
    }else{
      if(GEC_Year$Type[k]=="Flood"){
       GEC_Year$PremWAL3[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
      }else{
        GEC_Year$PremWAL3[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
      }
    }
    
    
    
  } 
  
  total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
  total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
  total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
  total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
  
  Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
}

Result <- Result[2:6,]

Result
```

# --
# Catastrophe
```{r}
library(dplyr)

# DATA
if (TRUE){
  claimCB = claim
    # Correcting quotation marks and initializing 'Type' column
  claimCB$Type <- ""
  
  # Loop to categorize events
  for (i in 1:nrow(claimCB)) {
    if (claimCB$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")) {
      claimCB$Type[i] <- "Flood"
    } else {
      claimCB$Type[i] <- "Normal"
    }
  }
  
  # Viewing the updated data
  # View(claimCB)
  
  # Filtering the data for 'Flood' events
  flood_claims <- claimCB[claimCB$Type == "Flood", ]   
  
  # GROUPING
  yearly_gross_incurred <- flood_claims %>%
  group_by(`Min Year`) %>%
  summarise(total_gross_incurred = sum(GROSS_INCURRED))
}

#number of flood per year (ASSUMPTION)
lambda <- 9/5
lvl <- data.frame(
  Lvl=c("High Risk","Middle Risk","Low Risk"),
  ROR=c(0.15,0.08,0.04),
  APQ = c(0.75,0.85,0.95),
  EPQ = c(0.85,0.95,0.99)
)

# Statistical
if(TRUE){
  sample_mean <-     mean(yearly_gross_incurred$total_gross_incurred)
  sample_variance <- var(yearly_gross_incurred$total_gross_incurred)
}

# Estimate mu and sigma (esimated parameter of lognormal)
if(TRUE){
  # Estimate mu and sigma using method of moments
  mu <- log(sample_mean^2 / sqrt(sample_variance + sample_mean^2))
  sigma <- sqrt(log(1 + sample_variance / sample_mean^2))
  
  # Print the estimated parameters
  print(paste("Estimated mu:", mu))
  print(paste("Estimated sigma:", sigma))
}

# Stimulation and export LVL
if(TRUE){
  n_sim <- 10000000
  
  # Generate random samples from the lognormal distribution
  simulated_losses <- rlnorm(n_sim, meanlog = mu, sdlog = sigma)
  
  for (i in 1:3){
    lvl$AP[i] <- quantile(simulated_losses, lvl$APQ[i])
    lvl$EP[i] <- quantile(simulated_losses, lvl$EPQ[i])
    lvl$principal[i] <- lvl$EP[i]-lvl$AP[i]
    lvl$no_investor[i] <- lvl$principal[i]/1000
  }
}
lvl

# Apply to data
flood_claims <- GEC[GEC$EVENT_CODE %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026"), ] 

catastrophe_exp = data.frame(no=1:5,years=seq(2019,2023))

coverCB = data.frame(no=1:5)
years = seq(2019,2023)
principal=sum(lvl$principal)

#Original
for(i in 1:5){
    coverCB$Year[i] = years[i]
    yearly = flood_claims[flood_claims$`Claim Year`==coverCB$Year[i],]
    
    if(nrow(yearly)==0){
      coverCB$cover[i] = 0
    }else{
      for(k in 1:nrow(yearly)){
      if(yearly$GROSS_INCURRED[k]>lvl$AP[1]){
        yearly$cover[k] = yearly$GROSS_INCURRED[k]-lvl$AP[1]
        
        if(yearly$GROSS_INCURRED[k]<lvl$EP[1]){
          lvl$principal[1] = lvl$principal[1]-yearly$cover[k]
          
        }else if(yearly$GROSS_INCURRED[k]<lvl$EP[2]){
          lvl$principal[1] = 0
          lvl$principal[2] = lvl$principal[2]-(yearly$cover[k]-lvl$EP[1])
          
        }else if(yearly$GROSS_INCURRED[k]<lvl$EP[3]){
          lvl$principal[1] = 0
          lvl$principal[2] = 0
          lvl$principal[3] = lvl$principal[3]-(yearly$cover[k]-lvl$EP[1]-lvl$EP[2])
        }
      }else{
          yearly$cover[k]=0
        }
      }
      coverCB$cover[i] = sum(yearly$cover)
      lvl
    }
    for (j in 1:3){
        catastrophe_exp$exp[i] = sum(lvl$principal*lvl$ROR)
    }
}
# assumption 
catastrophe_exp
coverCB
lvl
colnames(lvl) = c("Risk Level","Required rate of return","Attachment Point Quantile","Exhaustion Point Quantile","Attachment Point","Exhaustion Point","Principal","Number of Investor")

```
# --
# Data for motor
```{r}
motor <- data.frame(
  Year=c(2019,2020,2021,2022,2023),
  GPrem = c(60513120,78178940,89592170,100541210,111231110),
  GClaim = c(43039442.23848,61050872.39328,66408905.885252,77739468.9841,87244254.605832),
  GCom = 0,
  MExp = c(6724465.998192,9783422.002116,10134755.86257,12077422.364161,13041985.0179209)
)
```

# Motor XOL Parameter Tuning
```{r}
layers_motor <- data.frame(
  Layers = c("Combined XOL L1","Combined XOL L2"),
  Rate = c(0.025, 0.01),
  Deductible = c(2000000, 7000000),
  Limit = c(5000000, 20000000),
  AnnualL = c(20000000,40000000),
  Reinst = c(4,2)
)
```

# XOL for motor
```{r}
ResultM <- data.frame("Year","TotalD","TotalLR","TotalPrem")

for (i in 1:5){
  year <- motor$Year[i]
  gnpi_year <- motor$GPrem[i]
  
  motor_Year = motor_claim[motor_claim$`Accident Year`==year,]
  motor_Year = motor_Year[motor_Year$GROSS_INCURRED>2000000,]
  motor_Year$L1 = 0
  motor_Year$LARL1 = 0
  motor_Year$CoverL1 = 0
  motor_Year$L2 = 0
  motor_Year$LARL2 = 0
  motor_Year$CoverL2 = 0

  if(nrow(motor_Year)==0){
    total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
    total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
    total_tpremM = sum(layers_motor$Rate)*gnpi_year
    ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
    next
  }
  # RUN every claim
  for(k in 1:nrow(motor_Year)){
    loss = motor_Year$GROSS_INCURRED[k]
    
    #L1
    if(loss<=layers_motor$Deductible[1]){
      motor_Year$L1[k]=loss
    }else{
      motor_Year$L1[k]=layers_motor$Deductible[1]
    }
    
    #LAR L1
    motor_Year$LARL1[k] = min(min(loss-motor_Year$L1[k],layers_motor$Limit[1]),layers_motor$Limit[1]*(layers_motor$Reinst[1]))
    
    #Cover Remaining NML1
    if(k==1){
      motor_Year$CoverL1[k] = layers_motor$Limit[1]*layers_motor$Reinst[1]-motor_Year$LARL1[k]
    }else{
      motor_Year$CoverL1[k] = motor_Year$CoverL1[k-1]-motor_Year$LARL1[k]
    }
    
    #L2
    if(loss-motor_Year$L1[k]-motor_Year$LARL1[k]<=layers_motor$Deductible[2]){
      motor_Year$L2[k]=loss-motor_Year$L1[k]-motor_Year$LARL1[k]
    }else{
      motor_Year$L2[k]=layers_info$Deductible[2]
    }
    
    #LAR L2
    motor_Year$LARL2[k] = min(min(loss-motor_Year$L1[k]-motor_Year$LARL1[k]-motor_Year$L2[k],layers_motor$Limit[2]),layers_motor$Limit[2]*(layers_motor$Reinst[2]))
    
    #Cover Remaining NML2
    if(k==1){
      motor_Year$CoverL2[k] = layers_motor$Limit[2]*layers_motor$Reinst[2]-motor_Year$LARL2[k]
    }else{
      motor_Year$CoverL2[k] = motor_Year$CoverL2[k-1]-motor_Year$LARL2[k]
    }
    
  }
  total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
  total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
  total_tpremM = sum(layers_motor$Rate)*gnpi_year
  ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
}

ResultM <- ResultM[2:6,]

ResultM$GPrem = motor$GPrem
ResultM$GClaim = motor$GClaim
ResultM$GCom = 0
ResultM$MExp = motor$MExp

for (i in 1:5){
  ResultM$GIncur[i] = sum(motor_claim[motor_claim$`Accident Year`==motor$Year[i],"GROSS_INCURRED"])
}

ResultM
```

# --
# Combine all result
```{r}
retentionsum = data.frame(sum=c(1,2,3,4,5))

index = 1
for (i in c(2019,2020,2021,2022,2023)){
  retentionsum$gincur[index] = sum(claim[claim$`Min Year`==i,'GROSS_INCURRED'])
  index = index +1
}

index = 1
for (i in c(2019,2020,2021,2022,2023)){
  retentionsum$fincur[index] = sum(claim[claim$`Min Year`==i,'FAC_INCURRED'])
  index = index +1
}

years = c(2019,2020,2021,2022,2023)

outcome_df=data.frame(no=1:5)
for (i in 1:5){
  outcome_df$Year[i] = years[i]
  outcome_df$Total_exceed_treaty_limit_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
  outcome_df$Total_of_Ceded_Amount_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Ceded_Amount_loss"])
  outcome_df$Total_of_Retention_Loss[i] =sum(GEC[GEC$`Claim Year`==years[i],"Retention_loss"])
}

# Total before motor
if(TRUE){
  total = data.frame(Year=c(2019,2020,2021,2022,2023))
  
  total$net_premium =gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.)
  
  total$net_claim = retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.)-coverCB$cover
  
  total$loss_ratio_before = retentionsum$gincur/prem$gprem
  
  total$loss_ratio_after_facntreaty = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss)/gnpiT$sumGNPI
  
  total$loss_ratio_after_fanntreatynxol = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))
  
  total$loss_ratio_after_facntreatynxolnmotor = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.))
  
  total$loss_ratio_after_factreatyxolmotorCB = total$net_claim/total$net_premium
  
  # Before motor
  total$UWPBT_before_motor = (gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))-(retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem
  
  total$UWPAT_before_motor = (1-0.24)*total$UWPBT
  
  Ad_asset = 500000000
  for(i in c(5,4,3,2,1)){
    if(i==5){
      total$Ad_asset_before_motor[i] = Ad_asset
    }else{
      total$Ad_asset_before_motor[i] = total$Ad_asset_before_motor[i+1]-total$UWPAT_before_motor[i+1]
    }
  }
  
  total$CAR_before_motor = total$Ad_asset_before_motor/(0.8*((gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))))
}

# After motor
if(TRUE){
  total$UWPBT = total$net_premium-((retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-coverCB$cover)-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp
  total$UWPAT = (1-0.24)*total$UWPBT
  coverCB$cover
  
  Ad_asset = 500000000
  for(i in c(5,4,3,2,1)){
    if(i==5){
      total$Ad_asset[i] = Ad_asset
    }else{
      total$Ad_asset[i] = total$Ad_asset[i+1]-total$UWPAT[i+1]
    }
  }
  
  total$CAR = total$Ad_asset/(0.8*total$net_premium)
}

# After CB
if(TRUE){
  total$UWPBT_CB = total$net_premium-total$net_claim-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp-catastrophe_exp$exp
  total$UWPAT_CB = (1-0.24)*total$UWPBT_CB
  
  Ad_asset = 500000000
  for(i in c(5,4,3,2,1)){
    if(i==5){
      total$Ad_asset_CB[i] = Ad_asset
    }else{
      total$Ad_asset_CB[i] = total$Ad_asset_CB[i+1]-total$UWPAT_CB[i+1]
    }
  }
  
  total$CAR_CB = total$Ad_asset_CB/(0.8*total$net_premium)
}

total[,4:8] #loss ratio
total[,c(12,16,20)] #CAR
total[,c(9,10,13,14,17,18)] #UWP
total[,c(11,15,19)] #AD asset
total
mean(total$CAR)
sum(total$UWPAT)
```
# ============================
# FIND BEST MODEL (WITHOUT CONSIDER CATASTROPHE)
# Profit Function
```{r}
# Tune (or Default)
if (TRUE){
  Retention_lvlD = 9
  
  Retention_AmtD = 30000000
  
  layers_infoD <- data.frame(
      Layers = c("NonMarineLayer1", "NonMarineLayer2", "WholeAccLayer1", "WholeAccLayer2", "WholeAccLayer3"),
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
  )
  
  FloodRD = 1.2
  
  layers_motorD <- data.frame(
    Layers = c("Combined XOL L1","Combined XOL L2"),
    Rate = c(0.025, 0.01),
    Deductible = c(2000000, 7000000),
    Limit = c(5000000, 20000000),
    AnnualL = c(20000000,40000000),
    Reinst = c(4,2)
  )
}

best <- function(Retention_lvl=Retention_lvlD,Retention_Amt=Retention_AmtD,layers=layers_infoD,FloodR=FloodRD,layersM=layers_motorD){
  
  # Treaty Parameter Tuning
  if (TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
  }
  
  #Treaty Retention
  if(TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
    
    #RETENTION
    # calculate facultative ratio
    claim$Facultative_Ratio <- (claim$after_fac_incurred / claim$GROSS_INCURRED)
    
    # calculate gross_sum_insurred after facultative
    claim$Other_Reinsurance <- claim$Facultative_Ratio * claim$GROSS_SUM_INSURED
    
    # Calculate Retention Ratio
    Retention_Ratio <- ifelse(
      (Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance) >= 1,
      1,
      Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance
    )
    
    # Add a new column named "Retention Ratio" to the claim dataframe
    claim$Retention_Ratio <- Retention_Ratio
    
    # calculate the Retention_sum insured
    claim$Retention_sum_insured<-claim$Other_Reinsurance*claim$Retention_Ratio
    
    # calculate the Retention_loss
    claim$Retention_loss<-claim$after_fac_incurred*claim$Retention_Ratio
    
    
    
    #CEDED AMOUNT
    #calculate ceded amount ratio
    claim$Ceded_Amount_Ratio<- 1-claim$Retention_Ratio
    
    #calculate ceded amount_sum insured
    claim$Ceded_Amount_sum_insured<- claim$Other_Reinsurance*claim$Ceded_Amount_Ratio
    
    #calculate ceded amount loss
    claim$Ceded_Amount_loss<- claim$after_fac_incurred*claim$Ceded_Amount_Ratio
    
    
    
    #EXCEED TREATY LIMIT
    claim$Exceed_treaty_limit <- ifelse(claim$Other_Reinsurance > Capacity, claim$Other_Reinsurance - Capacity, 0)
    
    #ratio of exceed treaty limit in retention
    claim$Exceed_treaty_limit_ratio <- claim$Exceed_treaty_limit/claim$Retention_sum_insured
    
    #Exceed SUM_INCURRED
    claim$Exceed_treaty_limit_sum_incurred <- claim$Exceed_treaty_limit_ratio*claim$after_fac_incurred
  }
  
  # Treaty Calculation
  if(TRUE){
    library(dplyr)
    Treaty <- function(year){
      claim2019 <- claim[claim$`Min Year` == year, ]
      
      # Group by EVENT_CODE and summarize other columns by sum
      claim2019_combined <- claim2019 %>%
        group_by(EVENT_CODE) %>%
        summarise(
          GROSS_SUM_INSURED = sum(GROSS_SUM_INSURED, na.rm = TRUE),
          Other_Reinsurance = sum(`Other_Reinsurance`, na.rm = TRUE),  # Corrected column name
          GROSS_INCURRED = sum(GROSS_INCURRED, na.rm = TRUE),
          after_fac_incurred = sum(after_fac_incurred, na.rm = TRUE),
          .groups = "drop"
        )
      
      # Convert to dataframe
      claim2019_df <- as.data.frame(claim2019_combined)
      
      # Calculate facultative ratio
      claim2019_df$Facultative_Ratio <- (claim2019_df$after_fac_incurred / claim2019_df$GROSS_INCURRED)
      
      # Calculate gross_sum_insured after facultative
      claim2019_df$Other_Reinsurance <- claim2019_df$Facultative_Ratio * claim2019_df$GROSS_SUM_INSURED
      
      # Calculate Retention Ratio
      Retention_Ratio <- ifelse(
        (Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance) >= 1,
        1,
        Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance
      )
      
      # Add a new column named "Retention Ratio" to the claim2019_df dataframe
      claim2019_df$Retention_Ratio <- Retention_Ratio
      
      # Calculate the Retention_sum_insured
      claim2019_df$Retention_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Retention_Ratio
      
      # Calculate the Retention_loss
      claim2019_df$Retention_loss <- claim2019_df$after_fac_incurred * claim2019_df$Retention_Ratio
      
      # Calculate ceded amount ratio
      claim2019_df$Ceded_Amount_Ratio <- 1 - claim2019_df$Retention_Ratio
      
      # Calculate ceded amount_sum insured
      claim2019_df$Ceded_Amount_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate ceded amount loss
      claim2019_df$Ceded_Amount_loss <- claim2019_df$after_fac_incurred * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate Exceed Treaty Limit
      claim2019_df$Exceed_treaty_limit <- ifelse(claim2019_df$Other_Reinsurance > Capacity, claim2019_df$Other_Reinsurance - Capacity, 0)
      
      # Calculate ratio of exceed treaty limit in retention
      claim2019_df$Exceed_treaty_limit_ratio <- claim2019_df$Exceed_treaty_limit / claim2019_df$Retention_sum_insured
      
      # Calculate Exceed SUM_INCURRED
      claim2019_df$Exceed_treaty_limit_sum_incurred <- claim2019_df$Exceed_treaty_limit_ratio * claim2019_df$after_fac_incurred
      
      # Filter the dataframe for Event codes E001, E002, and E006
      filtered_df2019 <- claim2019_df[claim2019_df$EVENT_CODE %in% unique(claim2019$EVENT_CODE)[!is.na(unique(claim2019$EVENT_CODE))], ]
      
      for (i in 1:length(filtered_df2019$EVENT_CODE)){
        filtered_df2019$Date[i] = claim[which(claim$EVENT_CODE==filtered_df2019$EVENT_CODE[i]),"CLAIM_OCCURRENCE_DT"][[1]][1]
        filtered_df2019$`Claim Year`[i] = year
      }
      colnames(filtered_df2019)[16] = "Date"
      return(filtered_df2019)
    }
    
    NaEC = claim[is.na(claim$EVENT_CODE),][,c(11,16,21,14,19,20,22,23,24,25,26,27,28,29,30,4,5)]
    colnames(NaEC)[16] = "Date"
    
    TA = data.frame()
    Year = c(2019,2020,2021,2022,2023)
    for (i in 1:5){
      ans = Treaty(Year[i])
      TA = rbind(TA,ans)
    }
    GEC = rbind(TA,NaEC)
    # TA
    # GEC[which(NaEC$EVENT_CODE=="E006"),]
    # GEC
  }
  
  # Treaty Premium
  if(TRUE){
    sum_insured = c(0,100001,250001,500001,750001,1000001,2500001,5000001,7500001,10000001,12000001,14000001,16000001,18000001,20000001,25000001,30000001,40000001,50000001,70000001,100000001,200000001,300000001,400000001,500000001,1000000001)
    prem_avr = c(50000.5,175000.5,375000.5,625000.5,875000.5,1750000.5,3750001,6250001,8750001,11000001,13000001,15000001,17000001,19000001,22500001,27500001,35000001,45000001,60000001,85000001,150000001,250000001,350000001,450000001,750000001,1000000001)
    prem_data = data.frame(sum_insured=sum_insured,prem_avr=prem_avr,retention_ratio=rep(26,1))
    
    retention_ratio <- function(prem){
      if((Retention/prem+max(0,(prem-Capacity)/prem))>=1){
        return (1)
      }else{
        return(Retention/prem+max(0,(prem-Capacity)/prem))
      }
    }
    
    index = 1
    for (i in prem_data$prem_avr){
      prem_data[index,3] = retention_ratio(i)
      index = index+1
    }
    
    retention_prem = gprem
    retention_prem[,28] = retention_prem[,28]-fprem[,28]
    retention_prem[,29] = retention_prem[,29]-fprem[,29]
    retention_prem[,30] = retention_prem[,30]-fprem[,30]

    index = 1
    for (i in colnames(retention_prem)[5:30]){
      for (j in 1:nrow(retention_prem[,index+4])){
        retention_prem[j,index+4] = retention_prem[j,index+4]*prem_data[index,3]
        # print(j)
      }
      # print("out")
      index = index +1
    }
    # print(retention_prem[,29])
    
    for (i in 1:nrow(retention_prem)){
      retention_prem[i,"sum"]= sum(retention_prem[i,5:30])
    }
    
    gnpiT = data.frame(Year=c(2019,2020,2021,2022,2023))
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGNPI[index] = sum(retention_prem[retention_prem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGprem[index] = sum(gprem[gprem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumFprem[index] = sum(fprem[fprem$`Year`==i,'sum'])
      index = index +1
    }
  }
  
  # XOL Parameter Tuning
  if (TRUE){
    layers_info = layers
  
    Flood_Rate = FloodR
    no.layer = 5
    
    gnpi <- data.frame(
      Year = c(2019,2020,2021,2022,2023),
      GNPI = gnpiT$sumGNPI
    )
  }
  
  # XOL Calculation
  if (TRUE){
    GECK <- GEC[order(GEC$Date,decreasing=FALSE),]
Result <- data.frame("Year","TotalD","TotalLR","TotalRPrem","TotalPrem")
    
    for (i in 1:nrow(GECK)){
      if(GECK$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")){
        GECK$Type[i]="Flood"
      }else{
        GECK$Type[i]="Normal"
      }
    }
    
    for (i in 1:5){
      year <- gnpi$Year[i]
      gnpi_year <- gnpi$GNPI[i]
      
      # Group as year
      GEC_Year = GECK[GECK$`Claim Year`==year,]
      colnames(GEC_Year)[15] = "Loss"
      GEC_Year = GEC_Year[GEC_Year$Loss>layers_info$Deductible[1],]
      
      # If that year don't have, then skip
      if(nrow(GEC_Year)==0){
        total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
        total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
        total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
        total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
        
        Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
        next
      }
      
      # RUN every claim
      for(k in 1:nrow(GEC_Year)){
        loss = GEC_Year$Loss[k]
        
        #NML1
        if(loss<=layers_info$Deductible[1]){
          GEC_Year$NML1[k]=loss
        }else{
          GEC_Year$NML1[k]=layers_info$Deductible[1]
        }
        
        #LAR NML1
        GEC_Year$LARNML1[k] = min(min(loss-GEC_Year$NML1[k],layers_info$Limit[1]),layers_info$Limit[1]*(layers_info$Reinst[1]+1))
        
        #Cover Remaining NML1
        GEC_Year$CoverNML1[k] = layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$LARNML1[k]
        
        
        #Reinstated Premium 1
        if(GEC_Year$CoverNML1[k]<layers_info$Limit[1]){
          GEC_Year$PremNML1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML1[k]= Flood_Rate*layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }else{
            GEC_Year$PremNML1[k]= layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }
        }
        
        #NML2
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]<=layers_info$Deductible[2]){
          GEC_Year$NML2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]
        }else{
          GEC_Year$NML2[k]=layers_info$Deductible[2]
        }
    
        #LAR NML2
        GEC_Year$LARNML2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k],layers_info$Limit[2]),layers_info$Limit[2]*(layers_info$Reinst[2]+1))
    
        #Cover Remaining NML2
        GEC_Year$CoverNML2[k] = layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$LARNML2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverNML2[k]<layers_info$Limit[2]){
          GEC_Year$PremNML2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML2[k]= Flood_Rate*layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }else{
            GEC_Year$PremNML2[k]= layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }
        }
        
        sym = 3
        
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]<=layers_info$Deductible[sym]){
          GEC_Year$WAL1[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]
        }else{
          GEC_Year$WAL1[k]=layers_info$Deductible[sym]
        }
    
        #LAR WAL1
        GEC_Year$LARWAL1[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k],layers_info$Limit[sym]),layers_info$Limit[sym]*(layers_info$Reinst[sym]+1))
    
        #Cover Remaining WAL1
        GEC_Year$CoverWAL1[k] = layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$LARWAL1[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL1[k]<layers_info$Limit[sym]){
          GEC_Year$PremWAL1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL1[k]= Flood_Rate*layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }else{
            GEC_Year$PremWAL1[k]= layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }
        }
        
        
        sym2 = 4
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]
        }else{
          GEC_Year$WAL2[k]=layers_info$Deductible[sym2]
        }
        
        #LAR WAL2
        GEC_Year$LARWAL2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL2[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL2[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL2[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL2[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }
        }
        
        sym2 = 5
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL3[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]
        }else{
          GEC_Year$WAL3[k]=layers_info$Deductible[sym2]
        }
        
        #LAR wal3
        GEC_Year$LARWAL3[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]-GEC_Year$WAL3[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL3[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL3[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL3[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL3[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL3[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL3[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }
        }
        
        
        
      } 
      
      total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
      total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
      total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
      total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
      
      Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
    }
    
    Result <- Result[2:6,]
  }
  
  # Data for motor (Given)
  if (TRUE){
    motor <- data.frame(
    Year=c(2019,2020,2021,2022,2023),
    GPrem = c(60513120,78178940,89592170,100541210,111231110),
    GClaim = c(43039442.23848,61050872.39328,66408905.885252,77739468.9841,87244254.605832),
    GCom = 0,
    MExp = c(6724465.998192,9783422.002116,10134755.86257,12077422.364161,13041985.0179209)
  )
  }
  
  # XOL for Motor
  if (TRUE){
    layers_motor = layersM
    
    ResultM <- data.frame("Year","TotalD","TotalLR","TotalPrem")
    
    for (i in 1:5){
      year <- motor$Year[i]
      gnpi_year <- motor$GPrem[i]
      
      motor_Year = motor_claim[motor_claim$`Accident Year`==year,]
      motor_Year = motor_Year[motor_Year$GROSS_INCURRED>2000000,]
      motor_Year$L1 = 0
      motor_Year$LARL1 = 0
      motor_Year$CoverL1 = 0
      motor_Year$L2 = 0
      motor_Year$LARL2 = 0
      motor_Year$CoverL2 = 0
      
      if(nrow(motor_Year)==0){
        total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
        total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
        total_tpremM = sum(layers_motor$Rate)*gnpi_year
        ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
        next
      }
      # RUN every claim
      for(k in 1:nrow(motor_Year)){
        loss = motor_Year$GROSS_INCURRED[k]
        
        #L1
        if(loss<=layers_motor$Deductible[1]){
          motor_Year$L1[k]=loss
        }else{
          motor_Year$L1[k]=layers_motor$Deductible[1]
        }
        
        #LAR L1
        motor_Year$LARL1[k] = min(min(loss-motor_Year$L1[k],layers_motor$Limit[1]),layers_motor$Limit[1]*(layers_motor$Reinst[1]))
        
        #Cover Remaining NML1
        if(k==1){
          motor_Year$CoverL1[k] = layers_motor$Limit[1]*layers_motor$Reinst[1]-motor_Year$LARL1[k]
        }else{
          motor_Year$CoverL1[k] = motor_Year$CoverL1[k-1]-motor_Year$LARL1[k]
        }
        
        #L2
        if(loss-motor_Year$L1[k]-motor_Year$LARL1[k]<=layers_motor$Deductible[2]){
          motor_Year$L2[k]=loss-motor_Year$L1[k]-motor_Year$LARL1[k]
        }else{
          motor_Year$L2[k]=layers_info$Deductible[2]
        }
        
        #LAR L2
        motor_Year$LARL2[k] = min(min(loss-motor_Year$L1[k]-motor_Year$LARL1[k]-motor_Year$L2[k],layers_motor$Limit[2]),layers_motor$Limit[2]*(layers_motor$Reinst[2]))
        
        #Cover Remaining NML2
        if(k==1){
          motor_Year$CoverL2[k] = layers_motor$Limit[2]*layers_motor$Reinst[2]-motor_Year$LARL2[k]
        }else{
          motor_Year$CoverL2[k] = motor_Year$CoverL2[k-1]-motor_Year$LARL2[k]
        }
        
      }
      total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
      total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
      total_tpremM = sum(layers_motor$Rate)*gnpi_year
      ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
    }
    
    ResultM <- ResultM[2:6,]
    
    ResultM$GPrem = motor$GPrem
    ResultM$GClaim = motor$GClaim
    ResultM$GCom = 0
    ResultM$MExp = motor$MExp
    
    for (i in 1:5){
      ResultM$GIncur[i] = sum(motor_claim[motor_claim$`Accident Year`==motor$Year[i],"GROSS_INCURRED"])
    }
  }
  
  # Combine all result
  if (TRUE){
    retentionsum = data.frame(sum=c(1,2,3,4,5))
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$gincur[index] = sum(claim[claim$`Min Year`==i,'GROSS_INCURRED'])
      index = index +1
    }
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$fincur[index] = sum(claim[claim$`Min Year`==i,'FAC_INCURRED'])
      index = index +1
    }
    
    years = c(2019,2020,2021,2022,2023)
    outcome_df=data.frame(no=1:5)
    for (i in 1:5){
      outcome_df$Year[i] = years[i]
      outcome_df$Total_exceed_treaty_limit_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
      outcome_df$Total_of_Ceded_Amount_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Ceded_Amount_loss"])
      outcome_df$Total_of_Retention_Loss[i] =sum(GEC[GEC$`Claim Year`==years[i],"Retention_loss"])
    }
    
    total = data.frame(Year=c(2019,2020,2021,2022,2023))
    
    total$net_premium =gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.)
    
    total$net_claim = retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.)
    
    total$loss_ratio_before = retentionsum$gincur/prem$gprem
    
    total$loss_ratio_after_facntreaty = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss)/gnpiT$sumGNPI
    
    total$loss_ratio_after_fanntreatynxol = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))
    
    total$loss_ratio_after_facntreatynxolnmotor = total$net_claim/total$net_premium
    
    # Before motor
    total$UWPBT_before_motor = (gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))-(retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem
    
    total$UWPAT_before_motor = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset_before_motor[i] = Ad_asset
      }else{
        total$Ad_asset_before_motor[i] = total$Ad_asset_before_motor[i+1]-total$UWPAT_before_motor[i+1]
      }
    }
    
    total$CAR_before_motor = total$Ad_asset_before_motor/(0.8*((gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))))
    
    
    # After motor
    total$UWPBT = total$net_premium-total$net_claim-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp
    total$UWPAT = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset[i] = Ad_asset
      }else{
        total$Ad_asset[i] = total$Ad_asset[i+1]-total$UWPAT[i+1]
      }
 
    }
    
    total$CAR = total$Ad_asset/(0.8*total$net_premium)
    return(c(sum(total$UWPAT),mean(total$CAR),var(total$CAR)))
  }

}
print(best())

export_year <- function(Retention_lvl=Retention_lvlD,Retention_Amt=Retention_AmtD,layers=layers_infoD,FloodR=FloodRD,layersM=layers_motorD){
  
  # Treaty Parameter Tuning
  if (TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
  }
  
  #Treaty Retention
  if(TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
    
    #RETENTION
    # calculate facultative ratio
    claim$Facultative_Ratio <- (claim$after_fac_incurred / claim$GROSS_INCURRED)
    
    # calculate gross_sum_insurred after facultative
    claim$Other_Reinsurance <- claim$Facultative_Ratio * claim$GROSS_SUM_INSURED
    
    # Calculate Retention Ratio
    Retention_Ratio <- ifelse(
      (Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance) >= 1,
      1,
      Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance
    )
    
    # Add a new column named "Retention Ratio" to the claim dataframe
    claim$Retention_Ratio <- Retention_Ratio
    
    # calculate the Retention_sum insured
    claim$Retention_sum_insured<-claim$Other_Reinsurance*claim$Retention_Ratio
    
    # calculate the Retention_loss
    claim$Retention_loss<-claim$after_fac_incurred*claim$Retention_Ratio
    
    
    
    #CEDED AMOUNT
    #calculate ceded amount ratio
    claim$Ceded_Amount_Ratio<- 1-claim$Retention_Ratio
    
    #calculate ceded amount_sum insured
    claim$Ceded_Amount_sum_insured<- claim$Other_Reinsurance*claim$Ceded_Amount_Ratio
    
    #calculate ceded amount loss
    claim$Ceded_Amount_loss<- claim$after_fac_incurred*claim$Ceded_Amount_Ratio
    
    
    
    #EXCEED TREATY LIMIT
    claim$Exceed_treaty_limit <- ifelse(claim$Other_Reinsurance > Capacity, claim$Other_Reinsurance - Capacity, 0)
    
    #ratio of exceed treaty limit in retention
    claim$Exceed_treaty_limit_ratio <- claim$Exceed_treaty_limit/claim$Retention_sum_insured
    
    #Exceed SUM_INCURRED
    claim$Exceed_treaty_limit_sum_incurred <- claim$Exceed_treaty_limit_ratio*claim$after_fac_incurred
  }
  
  # Treaty Calculation
  if(TRUE){
    library(dplyr)
    Treaty <- function(year){
      claim2019 <- claim[claim$`Min Year` == year, ]
      
      # Group by EVENT_CODE and summarize other columns by sum
      claim2019_combined <- claim2019 %>%
        group_by(EVENT_CODE) %>%
        summarise(
          GROSS_SUM_INSURED = sum(GROSS_SUM_INSURED, na.rm = TRUE),
          Other_Reinsurance = sum(`Other_Reinsurance`, na.rm = TRUE),  # Corrected column name
          GROSS_INCURRED = sum(GROSS_INCURRED, na.rm = TRUE),
          after_fac_incurred = sum(after_fac_incurred, na.rm = TRUE),
          .groups = "drop"
        )
      
      # Convert to dataframe
      claim2019_df <- as.data.frame(claim2019_combined)
      
      # Calculate facultative ratio
      claim2019_df$Facultative_Ratio <- (claim2019_df$after_fac_incurred / claim2019_df$GROSS_INCURRED)
      
      # Calculate gross_sum_insured after facultative
      claim2019_df$Other_Reinsurance <- claim2019_df$Facultative_Ratio * claim2019_df$GROSS_SUM_INSURED
      
      # Calculate Retention Ratio
      Retention_Ratio <- ifelse(
        (Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance) >= 1,
        1,
        Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance
      )
      
      # Add a new column named "Retention Ratio" to the claim2019_df dataframe
      claim2019_df$Retention_Ratio <- Retention_Ratio
      
      # Calculate the Retention_sum_insured
      claim2019_df$Retention_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Retention_Ratio
      
      # Calculate the Retention_loss
      claim2019_df$Retention_loss <- claim2019_df$after_fac_incurred * claim2019_df$Retention_Ratio
      
      # Calculate ceded amount ratio
      claim2019_df$Ceded_Amount_Ratio <- 1 - claim2019_df$Retention_Ratio
      
      # Calculate ceded amount_sum insured
      claim2019_df$Ceded_Amount_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate ceded amount loss
      claim2019_df$Ceded_Amount_loss <- claim2019_df$after_fac_incurred * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate Exceed Treaty Limit
      claim2019_df$Exceed_treaty_limit <- ifelse(claim2019_df$Other_Reinsurance > Capacity, claim2019_df$Other_Reinsurance - Capacity, 0)
      
      # Calculate ratio of exceed treaty limit in retention
      claim2019_df$Exceed_treaty_limit_ratio <- claim2019_df$Exceed_treaty_limit / claim2019_df$Retention_sum_insured
      
      # Calculate Exceed SUM_INCURRED
      claim2019_df$Exceed_treaty_limit_sum_incurred <- claim2019_df$Exceed_treaty_limit_ratio * claim2019_df$after_fac_incurred
      
      # Filter the dataframe for Event codes E001, E002, and E006
      filtered_df2019 <- claim2019_df[claim2019_df$EVENT_CODE %in% unique(claim2019$EVENT_CODE)[!is.na(unique(claim2019$EVENT_CODE))], ]
      
      for (i in 1:length(filtered_df2019$EVENT_CODE)){
        filtered_df2019$Date[i] = claim[which(claim$EVENT_CODE==filtered_df2019$EVENT_CODE[i]),"CLAIM_OCCURRENCE_DT"][[1]][1]
        filtered_df2019$`Claim Year`[i] = year
      }
      colnames(filtered_df2019)[16] = "Date"
      return(filtered_df2019)
    }
    
    NaEC = claim[is.na(claim$EVENT_CODE),][,c(11,16,21,14,19,20,22,23,24,25,26,27,28,29,30,4,5)]
    colnames(NaEC)[16] = "Date"
    
    TA = data.frame()
    Year = c(2019,2020,2021,2022,2023)
    for (i in 1:5){
      ans = Treaty(Year[i])
      TA = rbind(TA,ans)
    }
    GEC = rbind(TA,NaEC)
    # TA
    # GEC[which(NaEC$EVENT_CODE=="E006"),]
    # GEC
  }
  
  # Treaty Premium
  if(TRUE){
    sum_insured = c(0,100001,250001,500001,750001,1000001,2500001,5000001,7500001,10000001,12000001,14000001,16000001,18000001,20000001,25000001,30000001,40000001,50000001,70000001,100000001,200000001,300000001,400000001,500000001,1000000001)
    prem_avr = c(50000.5,175000.5,375000.5,625000.5,875000.5,1750000.5,3750001,6250001,8750001,11000001,13000001,15000001,17000001,19000001,22500001,27500001,35000001,45000001,60000001,85000001,150000001,250000001,350000001,450000001,750000001,1000000001)
    prem_data = data.frame(sum_insured=sum_insured,prem_avr=prem_avr,retention_ratio=rep(26,1))
    
    retention_ratio <- function(prem){
      if((Retention/prem+max(0,(prem-Capacity)/prem))>=1){
        return (1)
      }else{
        return(Retention/prem+max(0,(prem-Capacity)/prem))
      }
    }
    
    index = 1
    for (i in prem_data$prem_avr){
      prem_data[index,3] = retention_ratio(i)
      index = index+1
    }
    
    retention_prem = gprem
    retention_prem[,28] = retention_prem[,28]-fprem[,28]
    retention_prem[,29] = retention_prem[,29]-fprem[,29]
    retention_prem[,30] = retention_prem[,30]-fprem[,30]

    index = 1
    for (i in colnames(retention_prem)[5:30]){
      for (j in 1:nrow(retention_prem[,index+4])){
        retention_prem[j,index+4] = retention_prem[j,index+4]*prem_data[index,3]
        # print(j)
      }
      # print("out")
      index = index +1
    }
    # print(retention_prem[,29])
    
    for (i in 1:nrow(retention_prem)){
      retention_prem[i,"sum"]= sum(retention_prem[i,5:30])
    }
    
    gnpiT = data.frame(Year=c(2019,2020,2021,2022,2023))
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGNPI[index] = sum(retention_prem[retention_prem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGprem[index] = sum(gprem[gprem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumFprem[index] = sum(fprem[fprem$`Year`==i,'sum'])
      index = index +1
    }
  }
  
  # XOL Parameter Tuning
  if (TRUE){
    layers_info = layers
  
    Flood_Rate = FloodR
    no.layer = 5
    
    gnpi <- data.frame(
      Year = c(2019,2020,2021,2022,2023),
      GNPI = gnpiT$sumGNPI
    )
  }
  
  # XOL Calculation
  if (TRUE){
    GECK <- GEC[order(GEC$Date,decreasing=FALSE),]
Result <- data.frame("Year","TotalD","TotalLR","TotalRPrem","TotalPrem")
    
    for (i in 1:nrow(GECK)){
      if(GECK$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")){
        GECK$Type[i]="Flood"
      }else{
        GECK$Type[i]="Normal"
      }
    }
    
    for (i in 1:5){
      year <- gnpi$Year[i]
      gnpi_year <- gnpi$GNPI[i]
      
      # Group as year
      GEC_Year = GECK[GECK$`Claim Year`==year,]
      colnames(GEC_Year)[15] = "Loss"
      GEC_Year = GEC_Year[GEC_Year$Loss>layers_info$Deductible[1],]
      
      # If that year don't have, then skip
      if(nrow(GEC_Year)==0){
        total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
        total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
        total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
        total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
        
        Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
        next
      }
      
      # RUN every claim
      for(k in 1:nrow(GEC_Year)){
        loss = GEC_Year$Loss[k]
        
        #NML1
        if(loss<=layers_info$Deductible[1]){
          GEC_Year$NML1[k]=loss
        }else{
          GEC_Year$NML1[k]=layers_info$Deductible[1]
        }
        
        #LAR NML1
        GEC_Year$LARNML1[k] = min(min(loss-GEC_Year$NML1[k],layers_info$Limit[1]),layers_info$Limit[1]*(layers_info$Reinst[1]+1))
        
        #Cover Remaining NML1
        GEC_Year$CoverNML1[k] = layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$LARNML1[k]
        
        
        #Reinstated Premium 1
        if(GEC_Year$CoverNML1[k]<layers_info$Limit[1]){
          GEC_Year$PremNML1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML1[k]= Flood_Rate*layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }else{
            GEC_Year$PremNML1[k]= layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }
        }
        
        #NML2
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]<=layers_info$Deductible[2]){
          GEC_Year$NML2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]
        }else{
          GEC_Year$NML2[k]=layers_info$Deductible[2]
        }
    
        #LAR NML2
        GEC_Year$LARNML2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k],layers_info$Limit[2]),layers_info$Limit[2]*(layers_info$Reinst[2]+1))
    
        #Cover Remaining NML2
        GEC_Year$CoverNML2[k] = layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$LARNML2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverNML2[k]<layers_info$Limit[2]){
          GEC_Year$PremNML2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML2[k]= Flood_Rate*layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }else{
            GEC_Year$PremNML2[k]= layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }
        }
        
        sym = 3
        
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]<=layers_info$Deductible[sym]){
          GEC_Year$WAL1[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]
        }else{
          GEC_Year$WAL1[k]=layers_info$Deductible[sym]
        }
    
        #LAR WAL1
        GEC_Year$LARWAL1[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k],layers_info$Limit[sym]),layers_info$Limit[sym]*(layers_info$Reinst[sym]+1))
    
        #Cover Remaining WAL1
        GEC_Year$CoverWAL1[k] = layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$LARWAL1[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL1[k]<layers_info$Limit[sym]){
          GEC_Year$PremWAL1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL1[k]= Flood_Rate*layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }else{
            GEC_Year$PremWAL1[k]= layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }
        }
        
        
        sym2 = 4
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]
        }else{
          GEC_Year$WAL2[k]=layers_info$Deductible[sym2]
        }
        
        #LAR WAL2
        GEC_Year$LARWAL2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL2[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL2[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL2[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL2[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }
        }
        
        sym2 = 5
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL3[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]
        }else{
          GEC_Year$WAL3[k]=layers_info$Deductible[sym2]
        }
        
        #LAR wal3
        GEC_Year$LARWAL3[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]-GEC_Year$WAL3[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL3[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL3[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL3[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL3[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL3[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL3[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }
        }
        
        
        
      } 
      
      total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
      total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
      total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
      total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
      
      Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
    }
    
    Result <- Result[2:6,]
  }
  
  # Data for motor (Given)
  if (TRUE){
    motor <- data.frame(
    Year=c(2019,2020,2021,2022,2023),
    GPrem = c(60513120,78178940,89592170,100541210,111231110),
    GClaim = c(43039442.23848,61050872.39328,66408905.885252,77739468.9841,87244254.605832),
    GCom = 0,
    MExp = c(6724465.998192,9783422.002116,10134755.86257,12077422.364161,13041985.0179209)
  )
  }
  
  # XOL for Motor
  if (TRUE){
    layers_motor = layersM
    
    ResultM <- data.frame("Year","TotalD","TotalLR","TotalPrem")
    
    for (i in 1:5){
      year <- motor$Year[i]
      gnpi_year <- motor$GPrem[i]
      
      motor_Year = motor_claim[motor_claim$`Accident Year`==year,]
      motor_Year = motor_Year[motor_Year$GROSS_INCURRED>2000000,]
      motor_Year$L1 = 0
      motor_Year$LARL1 = 0
      motor_Year$CoverL1 = 0
      motor_Year$L2 = 0
      motor_Year$LARL2 = 0
      motor_Year$CoverL2 = 0
      
      if(nrow(motor_Year)==0){
        total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
        total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
        total_tpremM = sum(layers_motor$Rate)*gnpi_year
        ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
        next
      }
      # RUN every claim
      for(k in 1:nrow(motor_Year)){
        loss = motor_Year$GROSS_INCURRED[k]
        
        #L1
        if(loss<=layers_motor$Deductible[1]){
          motor_Year$L1[k]=loss
        }else{
          motor_Year$L1[k]=layers_motor$Deductible[1]
        }
        
        #LAR L1
        motor_Year$LARL1[k] = min(min(loss-motor_Year$L1[k],layers_motor$Limit[1]),layers_motor$Limit[1]*(layers_motor$Reinst[1]))
        
        #Cover Remaining NML1
        if(k==1){
          motor_Year$CoverL1[k] = layers_motor$Limit[1]*layers_motor$Reinst[1]-motor_Year$LARL1[k]
        }else{
          motor_Year$CoverL1[k] = motor_Year$CoverL1[k-1]-motor_Year$LARL1[k]
        }
        
        #L2
        if(loss-motor_Year$L1[k]-motor_Year$LARL1[k]<=layers_motor$Deductible[2]){
          motor_Year$L2[k]=loss-motor_Year$L1[k]-motor_Year$LARL1[k]
        }else{
          motor_Year$L2[k]=layers_info$Deductible[2]
        }
        
        #LAR L2
        motor_Year$LARL2[k] = min(min(loss-motor_Year$L1[k]-motor_Year$LARL1[k]-motor_Year$L2[k],layers_motor$Limit[2]),layers_motor$Limit[2]*(layers_motor$Reinst[2]))
        
        #Cover Remaining NML2
        if(k==1){
          motor_Year$CoverL2[k] = layers_motor$Limit[2]*layers_motor$Reinst[2]-motor_Year$LARL2[k]
        }else{
          motor_Year$CoverL2[k] = motor_Year$CoverL2[k-1]-motor_Year$LARL2[k]
        }
        
      }
      total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
      total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
      total_tpremM = sum(layers_motor$Rate)*gnpi_year
      ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
    }
    
    ResultM <- ResultM[2:6,]
    
    ResultM$GPrem = motor$GPrem
    ResultM$GClaim = motor$GClaim
    ResultM$GCom = 0
    ResultM$MExp = motor$MExp
    
    for (i in 1:5){
      ResultM$GIncur[i] = sum(motor_claim[motor_claim$`Accident Year`==motor$Year[i],"GROSS_INCURRED"])
    }
  }
  
  # Combine all result
  if (TRUE){
    retentionsum = data.frame(sum=c(1,2,3,4,5))
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$gincur[index] = sum(claim[claim$`Min Year`==i,'GROSS_INCURRED'])
      index = index +1
    }
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$fincur[index] = sum(claim[claim$`Min Year`==i,'FAC_INCURRED'])
      index = index +1
    }
    
    years = c(2019,2020,2021,2022,2023)
    outcome_df=data.frame(no=1:5)
    for (i in 1:5){
      outcome_df$Year[i] = years[i]
      outcome_df$Total_exceed_treaty_limit_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
      outcome_df$Total_of_Ceded_Amount_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Ceded_Amount_loss"])
      outcome_df$Total_of_Retention_Loss[i] =sum(GEC[GEC$`Claim Year`==years[i],"Retention_loss"])
    }
    
    total = data.frame(Year=c(2019,2020,2021,2022,2023))
    
    total$net_premium =gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.)
    
    total$net_claim = retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.)
    
    total$loss_ratio_before = retentionsum$gincur/prem$gprem
    
    total$loss_ratio_after_facntreaty = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss)/gnpiT$sumGNPI
    
    total$loss_ratio_after_fanntreatynxol = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))
    
    total$loss_ratio_after_facntreatynxolnmotor = total$net_claim/total$net_premium
    
    # Before motor
    total$UWPBT_before_motor = (gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))-(retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem
    
    total$UWPAT_before_motor = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset_before_motor[i] = Ad_asset
      }else{
        total$Ad_asset_before_motor[i] = total$Ad_asset_before_motor[i+1]-total$UWPAT_before_motor[i+1]
      }
    }
    
    total$CAR_before_motor = total$Ad_asset_before_motor/(0.8*((gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))))
    
    
    # After motor
    total$UWPBT = total$net_premium-total$net_claim-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp
    total$UWPAT = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset[i] = Ad_asset
      }else{
        total$Ad_asset[i] = total$Ad_asset[i+1]-total$UWPAT[i+1]
      }
    }
    
    total$CAR = total$Ad_asset/(0.8*total$net_premium)
    return(total)
  }

}
```
# ==
# TREATY PARAMETER OPTIMIZATION
# Optimization Treaty: Using Greedy
```{r}

# Range for optimization
if (TRUE){
  retention_amounts <- seq(5000000,100000000,by=5000000)
  retention_levels <- seq(2,12,by=1)
  parameter_grid <- expand.grid(retention_level = retention_levels, retention_amount = retention_amounts)
  Compare = data.frame(retention_level = numeric(), retention_amount = numeric(),UWPAT=numeric(),CAR=numeric(),CARV=numeric())
}

# Optimization
for (i in 1:nrow(parameter_grid)) {
  retention_level <- parameter_grid$retention_level[i]
  retention_amount <- parameter_grid$retention_amount[i]
  
  ans <- best(Retention_lvl=retention_level, Retention_Amt=retention_amount)
  
  profit = ans[1]
  CAR = ans[2] 
  CARV = ans[3]
  
  Compare <- rbind(Compare, data.frame(retention_level = retention_level, retention_amount = retention_amount, UWPAT = profit,CAR=CAR,CARV=CARV))
}

Compare
```
# Continue: From the result, find the max
```{r}
# Restart R after run the greedy

max_profit = 100000000
min_profit = 50000000
max_var = 1.2
min_var = 0.8

weight_profit <- 0.4
weight_var <- 0.6

# Max
Compare[which.max((Compare$UWPAT-min_profit)/(max_profit-min_profit)*weight_profit-(Compare$CAR-min_var)/(max_var-min_var)*weight_var),]

# Arrange and get the top 10
Compare_sorted <- Compare[Compare$CAR<1.3,]
Compare_sorted <- Compare_sorted[with(Compare_sorted,order(-UWPAT)),][1:10,]
```

# Continue: Evaluate and Visualization
```{r}
library(ggplot2)
ggplot(Compare, aes(x = retention_level, y = retention_amount, fill = UWPAT)) +
  geom_tile() +
  labs(title = "Profit Heatmap", x = "Retention Level", y = "Retention Amount", fill = "Profit") +
  theme_minimal()
```
# Continue: Export to Excel
```{r}
install.packages("writexl")
library("writexl")
# Manually change filename
write_xlsx(Compare,"/Users/peyton/Downloads/Properity/hackathon/Best Model/Parameter Grid/1.xlsx")
```

# Best combination:
```{r}
# after
bestA <- export_year(4,20000000)
sum(bestA$UWPAT)
mean(bestA$CAR)
var(bestA$CAR)
bestA
```
# --
# Optimization Treaty: Using Genetic Algorithm
```{r}
library(GA)
library(parallel)
library(doParallel)

# Define the parameter ranges
lower_bounds <- c(2, 10000000)  # Min for retention level and amount
upper_bounds <- c(12, 100000000)  # Max for retention level and amount

max_profit = 100000000
min_profit = 50000000
max_var = 1.2
min_var = 1

weight_profit <- 0.2
weight_var <- 0.8

# Define the fitness function for the GA
fitness_function <- function(params) {
  retention_level <- round(params[1])
  retention_level <- max(min(retention_level, upper_bounds[1]), lower_bounds[1])
  retention_amount <- params[2]
  ans <- best(Retention_lvl=retention_level, Retention_Amt=retention_amount)
  profit <- ans[1]
  var <- ans[2]
  
  normalized_profit <- (profit - min_profit) / (max_profit - min_profit)
  normalized_var <- (var - min_var) / (max_var - min_var)
  
  combined_fitness <- weight_profit*normalized_profit-weight_var*normalized_var
  
  return(combined_fitness)
}

ga_result <- ga(
  type = "real-valued", 
  fitness = fitness_function, 
  lower = lower_bounds, 
  upper = upper_bounds, 
  popSize = 50,  #decrease to speed up (50) [population size]
  maxiter = 100,  #decrease to speed up (100) [number of generations]
  run = 50,   #decrease to speed up (50) [no. consecutive generations without improvement]
  parallel=TRUE # Enable parallel execution if possible(use multiple CPU to run)
)

optimal_parameters <- round(ga_result@solution)
optimal_combined <- ga_result@fitnessValue
optimal <- best(Retention_lvl=optimal_parameters[1],Retention_Amt = optimal_parameters[2])
print(optimal_parameters)
print(optimal_combined)
print(optimal)
```
# Continue: Evaluation and Visualization
```{r}
#     x1       x2
# [1,]  4 20575728
# [1] 74934996
print(best(Retention_lvl=4,Retention_Amt=20575728))
plot(ga_result)
# Y-axis -> Fitness value
# X-axis -> Generations
```


# Continue: Export to Excel
```{r}
# install.packages("writexl")
library("writexl")

optimal_parameters <- round(ga_result@solution)
optimal_profit <- best(optimal_parameters[1], optimal_parameters[2])
# optimal_expense <- expense_function(optimal_parameters[1], optimal_parameters[2])
convergence <- data.frame(Generation = 1:length(ga_result@fitness), Fitness = ga_result@fitness)

# Create data frames to export
df_parameters <- data.frame(Parameter = c("Retention Level", "Retention Amount"), Value = optimal_parameters)
df_results <- data.frame(Metric = c("Optimal Profit"), Value = c(optimal_profit))
df_convergence <- data.frame(Generation = 1:length(ga_result@fitnessValue), BestFitness = ga_result@fitnessValue)

# Export to Excel
write_xlsx(
  list(
    OptimalParameters = df_parameters,
    Results = df_results,
    Convergence = df_convergence
  ),
  # Manually change filename
  "/Users/peyton/Downloads/Properity/hackathon/Best Model/Genetic Algorithm/1.xlsx"
)

# Print confirmation
print("Export successful")

```











# Best combination:
```{r}
bestB <- export_year(2,25002618)
sum(bestB$UWPAT)
mean(bestB$CAR)
var(bestB$CAR)
bestB
```

# ==
# XOL PARAMETER OPTIMIZATION
```{r}
# REFERENCE
if(TRUE){
  record <- data.frame(na=1:30)
  test <- data.frame(
    Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
    Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
    Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
    Reinst = c(3,2,2,1,1)
  )
  ans <- best(layers=test)
  record$value[1] <- ans[1]
  record$car[1] <- ans[2]
  record$vcar[1] <- ans[3]
}

# INCREASE OR DECREASE LIMIT?
if(TRUE){
  # INCREASE by 2 mil, 4 mil, 6 mil (2-4)
  if(TRUE){
    # Every increase in limit of 1 mil, XOL Rate increase by 0.0005 and 0.0001 additive for non marine and whole account
    # Rate increase by 0.0025 and 0.0005
    
    k = 2
    g = 2
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 3
    g = 4
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 4
    g = 6
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
  }
  
  # DECREASE by 2 mil, 4 mil, 6 mil (5-7)
  if(TRUE){
    k = 5
    g = -2
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 6
    g = -4
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 7
    g = -6
    NL = c(15000000, 10000000, 20000000, 80000000, 30000000) + g*1000000
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(0.0005*g,2),rep(0.0001*g,3))
    test <- data.frame(
      Rate = NR,
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = NL,
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
  }
}
# AMONG 2-7, it is found that INCREASE could lead to higher profit without affecting the car too much. On contraty, it decrease the variance of car proving a more stable CAR.
# Therefore, increase limit

# INCREASE OR DECREASE REINST?
if(TRUE){
  #REFERENCE = c(3,2,2,1,1)
  if(TRUE){
    k = 8
    R = c(2,2,2,1,1)
    test <- data.frame(
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = R 
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 9
    R = c(3,1,2,1,1)
    test <- data.frame(
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = R 
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    k = 10
    R = c(3,2,1,1,1)
    test <- data.frame(
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = R 
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]   
    
    k = 11
    R = c(3,2,2,0,1)
    test <- data.frame(
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = R 
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
       
    k = 12
    R = c(3,2,2,1,0)
    test <- data.frame(
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = R 
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
  }
}
# AMONG 8-12, 11 seem to have higher profit and lower car with lower variance in car while other combination didn't show any improvement
# Therefore, whole account layer 2, n.o. reinst = 0 is the best combination

# INCREASE OR DECREASE DEDUCTIBLE? 
if(TRUE){
  # Assuming that every decrease of 1 mil in deductible, XOL Rate increase by 0.0005 and 0.0001 additive for non marine and whole account
  # DECREASE DEDUCTIBLE
  if(TRUE){
    # Decrease by 1 mil
    k = 13
    g = -1
    ND = c(5000000, 20000000, 0, 20000000, 100000000) + c(rep(g*1000000,2),0,rep(g*1000000,2))
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(g*0.0025,2),0,rep(g*0.0005,2))
    test <- data.frame(
      Rate = NR,
      Deductible = ND,
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    # Decrease by 3 mil
    k = 14
    g = -3
    ND = c(5000000, 20000000, 0, 20000000, 100000000) + c(rep(g*1000000,2),0,rep(g*1000000,2))
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(g*0.0025,2),0,rep(g*0.0005,2))
    test <- data.frame(
      Rate = NR,
      Deductible = ND,
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
  }
  
  # INCREASE DEDUCTIBLE
  if(TRUE){
    # Increase by 1 mil
    k = 15
    g = 1
    ND = c(5000000, 20000000, 0, 20000000, 100000000) + c(rep(g*1000000,2),0,rep(g*1000000,2))
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(g*0.0025,2),0,rep(g*0.0005,2))
    test <- data.frame(
      Rate = NR,
      Deductible = ND,
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
    
    # Increase by 3 mil
    k = 16
    g = 3
    ND = c(5000000, 20000000, 0, 20000000, 100000000) + c(rep(g*1000000,2),0,rep(g*1000000,2))
    NR = c(0.0185, 0.01, 0.008, 0.008, 0.003) + c(rep(g*0.0025,2),0,rep(g*0.0005,2))
    test <- data.frame(
      Rate = NR,
      Deductible = ND,
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
    )
    ans <- best(layers=test)
    record$value[k] <- ans[1]
    record$car[k] <- ans[2]
    record$vcar[k] <- ans[3]
  }
}
# AMONG 13-16, it is found that 14 is the best combination with highest profit and lowest car with lowest car variation
# Therefore, decrease deductible

record[1:k,]
```
# ==
# Stop loss (after Treaty, replacing XOL)
```{r}

# Tune
if(TRUE){
  years = seq(2019,2024)
  outcome_dfK = data.frame(no=1:5)
  for (i in 1:5){
    outcome_dfK$Year[i] = years[i]
    outcome_dfK$Exceed_treaty_limit[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
  }
  layers_infoK <- data.frame(
  Layers = c("NonMarineLayer1", "NonMarineLayer2", "WholeAccLayer1", "WholeAccLayer2", "WholeAccLayer3"),
  Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
  Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
  Loss_Recoverable = c(15000000, 10000000, 20000000, 80000000, 30000000),
  Loss = c(20000000, 30000000, 20000000, 100000000, 130000000),
  First_Claim = c(20000000, 50000000, 70000000, 170000000, 300000000),
  First_Reinstated_Cover = c(320000000, 350000000, 370000000, 470000000, 600000000),
  Second_Reinstated_Cover = c(620000000, 650000000, 670000000, NA, NA),
  Third_Reinstated_Cover = c(690000000, NA, NA, NA, NA)
  )
  GNPIK = gnpiT$sumGNPI
}

stop_loss <- function(outcome_df=outcome_dfK,layers_info=layers_infoK,GNPI=GNPIK){
  loss_per_year <- data.frame(
  Year = c(2019,2020,2021,2022,2023),
  Loss = outcome_df$Exceed_treaty_limit
  )
  gnpi <- data.frame(
    Year = c(2019,2020,2021,2022,2023),
    GNPI = GNPI
  )
  for (i in 1:nrow(loss_per_year)) {
    year <- loss_per_year$Year[i]
    year_loss <- loss_per_year$Loss[i]
    gnpi_year <- gnpi$GNPI[i]
    for(j in 1:5){
      A <- 0
      if(j==1){
        if(year_loss>layers_info[j,6]){
          A<-layers_info[j,5]
        }else{
          A<-year_loss
        }
      }else{
        if(year_loss>layers_info[j,6]){
          A<-layers_info[j,5]
        }else{
          A<-year_loss-layers_info[j-1,6]
        }
      }
      loss_per_year[i,2+j] = max(A,0)
    }
    for(j in 1:5){
      B <- 0
      if(j==1){
        if(year_loss>layers_info[j,7]){
          A<-layers_info[j,5]
        }else{
          A<-year_loss-layers_info[5,6]
        }
      }else{
        if(year_loss>layers_info[j,7]){
          A<-layers_info[j,5]
        }else{
          A<-year_loss-layers_info[j-1,7]
        }
      }
      loss_per_year[i,7+j] = max(B,0)
    }
  }
  
  for (i in 1:5){
    loss_recoverable_sum = 0
    for(j in 1:5){
      if(loss_per_year[i,j+2]>layers_info[j,3]){
        loss_recoverable_sum = loss_recoverable_sum + (loss_per_year[i,j+2]-layers_info[j,3])
      }
    }
    for(j in 1:5){
      if(loss_per_year[i,j+7]>layers_info[j,3]){
        loss_recoverable_sum = loss_recoverable_sum + (loss_per_year[i,j+7]-layers_info[j,3])
      }
    }
    loss_per_year[i,"loss_recoverable_sum"] = loss_recoverable_sum
  }
  
  loss_per_year$Deductible = loss_per_year$Loss-loss_per_year$loss_recoverable_sum
  
  #XOL Reinsurance Premium
  for (i in 1:5){
    Rprem = 0
    for(j in 1:5){
      if(loss_per_year[i,j+2]>layers_info[j,3]){
        Rprem = Rprem + gnpi[i,2]*layers_info[j,2]
      }
    }
    loss_per_year[i,"Rprem"] = Rprem
  }
  
  # Reinstallment Prem
  if(TRUE){
      for (i in 1:5){
      Rinst = 0
      for(j in 1:5){
        if(loss_per_year[i,j+2]>layers_info[j,3]){
          Rinst = Rinst + layers_info[j,2]*gnpi[i,2]*(loss_per_year[i,j+2]-layers_info[j,3])/layers_info[j,4]
        }
      }
    
      for(j in 1:5){
        if(loss_per_year[i,j+7]>layers_info[j,3]){
          Rinst = Rinst + layers_info[j,2]*gnpi[i,2]*(loss_per_year[i,j+7]-layers_info[j,3])/layers_info[j,4]
        }
      }
      loss_per_year[i,"Rinst"] = Rinst
    }
  }
  
  return(loss_per_year)

}

stop_loss()

```

# ============================
# BEST MODEL
# profit function with catastrophe
```{r}
# Tune (or Default)
if (TRUE){
    Retention_lvlD = 9
    
    Retention_AmtD = 30000000
    
    layers_infoD <- data.frame(
        Layers = c("NonMarineLayer1", "NonMarineLayer2", "WholeAccLayer1", "WholeAccLayer2", "WholeAccLayer3"),
        Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
        Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
        Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
        Reinst = c(3,2,2,1,1)
    )
    
    FloodRD = 1.2
    
    layers_motorD <- data.frame(
      Layers = c("Combined XOL L1","Combined XOL L2"),
      Rate = c(0.025, 0.01),
      Deductible = c(2000000, 7000000),
      Limit = c(5000000, 20000000),
      AnnualL = c(20000000,40000000),
      Reinst = c(4,2))
      
    lambdaD = 9/5
    
    lvlD = data.frame(
    Lvl=c("High Risk","Middle Risk","Low Risk"),
      ROR=c(0.15,0.08,0.04),
      APQ = c(0.75,0.85,0.95),
      EPQ = c(0.85,0.95,0.99)
      )
}

export_year_with_catastrophe <- function(Retention_lvl=Retention_lvlD,Retention_Amt=Retention_AmtD,layers=layers_infoD,FloodR=FloodRD,layersM=layers_motorD,lambda=lambdaD,lvl=lvlD){
  
  # Treaty Parameter Tuning
  if (TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
  }
  
  #Treaty Retention
  if(TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
    
    #RETENTION
    # calculate facultative ratio
    claim$Facultative_Ratio <- (claim$after_fac_incurred / claim$GROSS_INCURRED)
    
    # calculate gross_sum_insurred after facultative
    claim$Other_Reinsurance <- claim$Facultative_Ratio * claim$GROSS_SUM_INSURED
    
    # Calculate Retention Ratio
    Retention_Ratio <- ifelse(
      (Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance) >= 1,
      1,
      Retention / claim$Other_Reinsurance + pmax(0, claim$Other_Reinsurance - Capacity) / claim$Other_Reinsurance
    )
    
    # Add a new column named "Retention Ratio" to the claim dataframe
    claim$Retention_Ratio <- Retention_Ratio
    
    # calculate the Retention_sum insured
    claim$Retention_sum_insured<-claim$Other_Reinsurance*claim$Retention_Ratio
    
    # calculate the Retention_loss
    claim$Retention_loss<-claim$after_fac_incurred*claim$Retention_Ratio
    
    
    
    #CEDED AMOUNT
    #calculate ceded amount ratio
    claim$Ceded_Amount_Ratio<- 1-claim$Retention_Ratio
    
    #calculate ceded amount_sum insured
    claim$Ceded_Amount_sum_insured<- claim$Other_Reinsurance*claim$Ceded_Amount_Ratio
    
    #calculate ceded amount loss
    claim$Ceded_Amount_loss<- claim$after_fac_incurred*claim$Ceded_Amount_Ratio
    
    
    
    #EXCEED TREATY LIMIT
    claim$Exceed_treaty_limit <- ifelse(claim$Other_Reinsurance > Capacity, claim$Other_Reinsurance - Capacity, 0)
    
    #ratio of exceed treaty limit in retention
    claim$Exceed_treaty_limit_ratio <- claim$Exceed_treaty_limit/claim$Retention_sum_insured
    
    #Exceed SUM_INCURRED
    claim$Exceed_treaty_limit_sum_incurred <- claim$Exceed_treaty_limit_ratio*claim$after_fac_incurred
  }
  
  # Treaty Calculation
  if(TRUE){
    library(dplyr)
    Treaty <- function(year){
      claim2019 <- claim[claim$`Min Year` == year, ]
      
      # Group by EVENT_CODE and summarize other columns by sum
      claim2019_combined <- claim2019 %>%
        group_by(EVENT_CODE) %>%
        summarise(
          GROSS_SUM_INSURED = sum(GROSS_SUM_INSURED, na.rm = TRUE),
          Other_Reinsurance = sum(`Other_Reinsurance`, na.rm = TRUE),  # Corrected column name
          GROSS_INCURRED = sum(GROSS_INCURRED, na.rm = TRUE),
          after_fac_incurred = sum(after_fac_incurred, na.rm = TRUE),
          .groups = "drop"
        )
      
      # Convert to dataframe
      claim2019_df <- as.data.frame(claim2019_combined)
      
      # Calculate facultative ratio
      claim2019_df$Facultative_Ratio <- (claim2019_df$after_fac_incurred / claim2019_df$GROSS_INCURRED)
      
      # Calculate gross_sum_insured after facultative
      claim2019_df$Other_Reinsurance <- claim2019_df$Facultative_Ratio * claim2019_df$GROSS_SUM_INSURED
      
      # Calculate Retention Ratio
      Retention_Ratio <- ifelse(
        (Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance) >= 1,
        1,
        Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance
      )
      
      # Add a new column named "Retention Ratio" to the claim2019_df dataframe
      claim2019_df$Retention_Ratio <- Retention_Ratio
      
      # Calculate the Retention_sum_insured
      claim2019_df$Retention_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Retention_Ratio
      
      # Calculate the Retention_loss
      claim2019_df$Retention_loss <- claim2019_df$after_fac_incurred * claim2019_df$Retention_Ratio
      
      # Calculate ceded amount ratio
      claim2019_df$Ceded_Amount_Ratio <- 1 - claim2019_df$Retention_Ratio
      
      # Calculate ceded amount_sum insured
      claim2019_df$Ceded_Amount_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate ceded amount loss
      claim2019_df$Ceded_Amount_loss <- claim2019_df$after_fac_incurred * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate Exceed Treaty Limit
      claim2019_df$Exceed_treaty_limit <- ifelse(claim2019_df$Other_Reinsurance > Capacity, claim2019_df$Other_Reinsurance - Capacity, 0)
      
      # Calculate ratio of exceed treaty limit in retention
      claim2019_df$Exceed_treaty_limit_ratio <- claim2019_df$Exceed_treaty_limit / claim2019_df$Retention_sum_insured
      
      # Calculate Exceed SUM_INCURRED
      claim2019_df$Exceed_treaty_limit_sum_incurred <- claim2019_df$Exceed_treaty_limit_ratio * claim2019_df$after_fac_incurred
      
      # Filter the dataframe for Event codes E001, E002, and E006
      filtered_df2019 <- claim2019_df[claim2019_df$EVENT_CODE %in% unique(claim2019$EVENT_CODE)[!is.na(unique(claim2019$EVENT_CODE))], ]
      
      for (i in 1:length(filtered_df2019$EVENT_CODE)){
        filtered_df2019$Date[i] = claim[which(claim$EVENT_CODE==filtered_df2019$EVENT_CODE[i]),"CLAIM_OCCURRENCE_DT"][[1]][1]
        filtered_df2019$`Claim Year`[i] = year
      }
      colnames(filtered_df2019)[16] = "Date"
      return(filtered_df2019)
    }
    
    NaEC = claim[is.na(claim$EVENT_CODE),][,c(11,16,21,14,19,20,22,23,24,25,26,27,28,29,30,4,5)]
    colnames(NaEC)[16] = "Date"
    
    TA = data.frame()
    Year = c(2019,2020,2021,2022,2023)
    for (i in 1:5){
      ans = Treaty(Year[i])
      TA = rbind(TA,ans)
    }
    GEC = rbind(TA,NaEC)
    # TA
    # GEC[which(NaEC$EVENT_CODE=="E006"),]
    # GEC
  }
  
  # Treaty Premium
  if(TRUE){
    sum_insured = c(0,100001,250001,500001,750001,1000001,2500001,5000001,7500001,10000001,12000001,14000001,16000001,18000001,20000001,25000001,30000001,40000001,50000001,70000001,100000001,200000001,300000001,400000001,500000001,1000000001)
    prem_avr = c(50000.5,175000.5,375000.5,625000.5,875000.5,1750000.5,3750001,6250001,8750001,11000001,13000001,15000001,17000001,19000001,22500001,27500001,35000001,45000001,60000001,85000001,150000001,250000001,350000001,450000001,750000001,1000000001)
    prem_data = data.frame(sum_insured=sum_insured,prem_avr=prem_avr,retention_ratio=rep(26,1))
    
    retention_ratio <- function(prem){
      if((Retention/prem+max(0,(prem-Capacity)/prem))>=1){
        return (1)
      }else{
        return(Retention/prem+max(0,(prem-Capacity)/prem))
      }
    }
    
    index = 1
    for (i in prem_data$prem_avr){
      prem_data[index,3] = retention_ratio(i)
      index = index+1
    }
    
    retention_prem = gprem
    retention_prem[,28] = retention_prem[,28]-fprem[,28]
    retention_prem[,29] = retention_prem[,29]-fprem[,29]
    retention_prem[,30] = retention_prem[,30]-fprem[,30]

    index = 1
    for (i in colnames(retention_prem)[5:30]){
      for (j in 1:nrow(retention_prem[,index+4])){
        retention_prem[j,index+4] = retention_prem[j,index+4]*prem_data[index,3]
        # print(j)
      }
      # print("out")
      index = index +1
    }
    # print(retention_prem[,29])
    
    for (i in 1:nrow(retention_prem)){
      retention_prem[i,"sum"]= sum(retention_prem[i,5:30])
    }
    
    gnpiT = data.frame(Year=c(2019,2020,2021,2022,2023))
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGNPI[index] = sum(retention_prem[retention_prem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGprem[index] = sum(gprem[gprem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumFprem[index] = sum(fprem[fprem$`Year`==i,'sum'])
      index = index +1
    }
  }
  
  # XOL Parameter Tuning
  if (TRUE){
    layers_info = layers
  
    Flood_Rate = FloodR
    no.layer = 5
    
    gnpi <- data.frame(
      Year = c(2019,2020,2021,2022,2023),
      GNPI = gnpiT$sumGNPI
    )
  }
  
  # XOL Calculation
  if (TRUE){
    GECK <- GEC[order(GEC$Date,decreasing=FALSE),]
Result <- data.frame("Year","TotalD","TotalLR","TotalRPrem","TotalPrem")
    
    for (i in 1:nrow(GECK)){
      if(GECK$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")){
        GECK$Type[i]="Flood"
      }else{
        GECK$Type[i]="Normal"
      }
    }
    
    for (i in 1:5){
      year <- gnpi$Year[i]
      gnpi_year <- gnpi$GNPI[i]
      
      # Group as year
      GEC_Year = GECK[GECK$`Claim Year`==year,]
      colnames(GEC_Year)[15] = "Loss"
      GEC_Year = GEC_Year[GEC_Year$Loss>layers_info$Deductible[1],]
      
      # If that year don't have, then skip
      if(nrow(GEC_Year)==0){
        total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
        total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
        total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
        total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
        
        Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
        next
      }
      
      # RUN every claim
      for(k in 1:nrow(GEC_Year)){
        loss = GEC_Year$Loss[k]
        
        #NML1
        if(loss<=layers_info$Deductible[1]){
          GEC_Year$NML1[k]=loss
        }else{
          GEC_Year$NML1[k]=layers_info$Deductible[1]
        }
        
        #LAR NML1
        GEC_Year$LARNML1[k] = min(min(loss-GEC_Year$NML1[k],layers_info$Limit[1]),layers_info$Limit[1]*(layers_info$Reinst[1]+1))
        
        #Cover Remaining NML1
        GEC_Year$CoverNML1[k] = layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$LARNML1[k]
        
        
        #Reinstated Premium 1
        if(GEC_Year$CoverNML1[k]<layers_info$Limit[1]){
          GEC_Year$PremNML1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML1[k]= Flood_Rate*layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }else{
            GEC_Year$PremNML1[k]= layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }
        }
        
        #NML2
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]<=layers_info$Deductible[2]){
          GEC_Year$NML2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]
        }else{
          GEC_Year$NML2[k]=layers_info$Deductible[2]
        }
    
        #LAR NML2
        GEC_Year$LARNML2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k],layers_info$Limit[2]),layers_info$Limit[2]*(layers_info$Reinst[2]+1))
    
        #Cover Remaining NML2
        GEC_Year$CoverNML2[k] = layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$LARNML2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverNML2[k]<layers_info$Limit[2]){
          GEC_Year$PremNML2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML2[k]= Flood_Rate*layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }else{
            GEC_Year$PremNML2[k]= layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }
        }
        
        sym = 3
        
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]<=layers_info$Deductible[sym]){
          GEC_Year$WAL1[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]
        }else{
          GEC_Year$WAL1[k]=layers_info$Deductible[sym]
        }
    
        #LAR WAL1
        GEC_Year$LARWAL1[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k],layers_info$Limit[sym]),layers_info$Limit[sym]*(layers_info$Reinst[sym]+1))
    
        #Cover Remaining WAL1
        GEC_Year$CoverWAL1[k] = layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$LARWAL1[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL1[k]<layers_info$Limit[sym]){
          GEC_Year$PremWAL1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL1[k]= Flood_Rate*layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }else{
            GEC_Year$PremWAL1[k]= layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }
        }
        
        
        sym2 = 4
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]
        }else{
          GEC_Year$WAL2[k]=layers_info$Deductible[sym2]
        }
        
        #LAR WAL2
        GEC_Year$LARWAL2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL2[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL2[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL2[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL2[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }
        }
        
        sym2 = 5
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL3[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]
        }else{
          GEC_Year$WAL3[k]=layers_info$Deductible[sym2]
        }
        
        #LAR wal3
        GEC_Year$LARWAL3[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]-GEC_Year$WAL3[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL3[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL3[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL3[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL3[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL3[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL3[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }
        }
        
        
        
      } 
      
      total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
      total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
      total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
      total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
      
      Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
    }
    
    Result <- Result[2:6,]
  }
  
  # Data for motor (Given)
  if (TRUE){
    motor <- data.frame(
    Year=c(2019,2020,2021,2022,2023),
    GPrem = c(60513120,78178940,89592170,100541210,111231110),
    GClaim = c(43039442.23848,61050872.39328,66408905.885252,77739468.9841,87244254.605832),
    GCom = 0,
    MExp = c(6724465.998192,9783422.002116,10134755.86257,12077422.364161,13041985.0179209)
  )
  }
  
  # XOL for Motor
  if (TRUE){
    layers_motor = layersM
    
    ResultM <- data.frame("Year","TotalD","TotalLR","TotalPrem")
    
    for (i in 1:5){
      year <- motor$Year[i]
      gnpi_year <- motor$GPrem[i]
      
      motor_Year = motor_claim[motor_claim$`Accident Year`==year,]
      motor_Year = motor_Year[motor_Year$GROSS_INCURRED>2000000,]
      motor_Year$L1 = 0
      motor_Year$LARL1 = 0
      motor_Year$CoverL1 = 0
      motor_Year$L2 = 0
      motor_Year$LARL2 = 0
      motor_Year$CoverL2 = 0
      
      if(nrow(motor_Year)==0){
        total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
        total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
        total_tpremM = sum(layers_motor$Rate)*gnpi_year
        ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
        next
      }
      # RUN every claim
      for(k in 1:nrow(motor_Year)){
        loss = motor_Year$GROSS_INCURRED[k]
        
        #L1
        if(loss<=layers_motor$Deductible[1]){
          motor_Year$L1[k]=loss
        }else{
          motor_Year$L1[k]=layers_motor$Deductible[1]
        }
        
        #LAR L1
        motor_Year$LARL1[k] = min(min(loss-motor_Year$L1[k],layers_motor$Limit[1]),layers_motor$Limit[1]*(layers_motor$Reinst[1]))
        
        #Cover Remaining NML1
        if(k==1){
          motor_Year$CoverL1[k] = layers_motor$Limit[1]*layers_motor$Reinst[1]-motor_Year$LARL1[k]
        }else{
          motor_Year$CoverL1[k] = motor_Year$CoverL1[k-1]-motor_Year$LARL1[k]
        }
        
        #L2
        if(loss-motor_Year$L1[k]-motor_Year$LARL1[k]<=layers_motor$Deductible[2]){
          motor_Year$L2[k]=loss-motor_Year$L1[k]-motor_Year$LARL1[k]
        }else{
          motor_Year$L2[k]=layers_info$Deductible[2]
        }
        
        #LAR L2
        motor_Year$LARL2[k] = min(min(loss-motor_Year$L1[k]-motor_Year$LARL1[k]-motor_Year$L2[k],layers_motor$Limit[2]),layers_motor$Limit[2]*(layers_motor$Reinst[2]))
        
        #Cover Remaining NML2
        if(k==1){
          motor_Year$CoverL2[k] = layers_motor$Limit[2]*layers_motor$Reinst[2]-motor_Year$LARL2[k]
        }else{
          motor_Year$CoverL2[k] = motor_Year$CoverL2[k-1]-motor_Year$LARL2[k]
        }
        
      }
      total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
      total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
      total_tpremM = sum(layers_motor$Rate)*gnpi_year
      ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
    }
    
    ResultM <- ResultM[2:6,]
    
    ResultM$GPrem = motor$GPrem
    ResultM$GClaim = motor$GClaim
    ResultM$GCom = 0
    ResultM$MExp = motor$MExp
    
    for (i in 1:5){
      ResultM$GIncur[i] = sum(motor_claim[motor_claim$`Accident Year`==motor$Year[i],"GROSS_INCURRED"])
    }
  }
  
  # Catastrophe
  if(TRUE){
    library(dplyr)
  
  # DATA
    if (TRUE){
      claimCB = claim
        # Correcting quotation marks and initializing 'Type' column
      claimCB$Type <- ""
      
      # Loop to categorize events
      for (i in 1:nrow(claimCB)) {
        if (claimCB$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")) {
          claimCB$Type[i] <- "Flood"
        } else {
          claimCB$Type[i] <- "Normal"
        }
      }
      
      # Viewing the updated data
      # View(claimCB)
      
      # Filtering the data for 'Flood' events
      flood_claims <- claimCB[claimCB$Type == "Flood", ]   
      
      # GROUPING
      yearly_gross_incurred <- flood_claims %>%
      group_by(`Min Year`) %>%
      summarise(total_gross_incurred = sum(GROSS_INCURRED))
      }
      
      #number of flood per year (ASSUMPTION)
      lambda <- lambdaD
      lvl <- lvlD
      
    # Statistical
    if(TRUE){
      sample_mean <-     mean(yearly_gross_incurred$total_gross_incurred)
      sample_variance <- var(yearly_gross_incurred$total_gross_incurred)
    }
    
    # Estimate mu and sigma (esimated parameter of lognormal)
    if(TRUE){
      # Estimate mu and sigma using method of moments
      mu <- log(sample_mean^2 / sqrt(sample_variance + sample_mean^2))
      sigma <- sqrt(log(1 + sample_variance / sample_mean^2))
    }
    
    # Stimulation and export LVL
    if(TRUE){
      n_sim <- 10000000
      
      # Generate random samples from the lognormal distribution
      simulated_losses <- rlnorm(n_sim, meanlog = mu, sdlog = sigma)
      
      for (i in 1:3){
        lvl$AP[i] <- quantile(simulated_losses, lvl$APQ[i])
        lvl$EP[i] <- quantile(simulated_losses, lvl$EPQ[i])
        lvl$principal[i] <- lvl$EP[i]-lvl$AP[i]
        lvl$no_investor[i] <- lvl$principal[i]/1000
        }
      }
      
      # Apply to data
    flood_claims <- GEC[GEC$EVENT_CODE %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026"), ] 
    
    catastrophe_exp = data.frame(no=1:5,years=seq(2019,2023))
    
    coverCB = data.frame(no=1:5)
    years = seq(2019,2023)
    
    #Original
    for(i in 1:5){
    coverCB$Year[i] = years[i]
    yearly = flood_claims[flood_claims$`Claim Year`==coverCB$Year[i],]
    
    if(nrow(yearly)==0){
      coverCB$cover[i] = 0
    }else{
      for(k in 1:nrow(yearly)){
      if(yearly$GROSS_INCURRED[k]>lvl$AP[1]){
        yearly$cover[k] = yearly$GROSS_INCURRED[k]-lvl$AP[1]
        
        if(yearly$GROSS_INCURRED[k]<lvl$EP[1]){
          lvl$principal[1] = lvl$principal[1]-yearly$cover[k]
          
        }else if(yearly$GROSS_INCURRED[k]<lvl$EP[2]){
          lvl$principal[1] = 0
          lvl$principal[2] = lvl$principal[2]-(yearly$cover[k]-lvl$EP[1])
          
        }else if(yearly$GROSS_INCURRED[k]<lvl$EP[3]){
          lvl$principal[1] = 0
          lvl$principal[2] = 0
          lvl$principal[3] = lvl$principal[3]-(yearly$cover[k]-lvl$EP[1]-lvl$EP[2])
        }
      }else{
          yearly$cover[k]=0
        }
      }
      coverCB$cover[i] = sum(yearly$cover)
      lvl
    }
    for (j in 1:3){
        catastrophe_exp$exp[i] = sum(lvl$principal*lvl$ROR)
    }
    }
    
  }
  
  # Combine all result
  if (TRUE){
    retentionsum = data.frame(sum=c(1,2,3,4,5))
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$gincur[index] = sum(claim[claim$`Min Year`==i,'GROSS_INCURRED'])
      index = index +1
    }
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$fincur[index] = sum(claim[claim$`Min Year`==i,'FAC_INCURRED'])
      index = index +1
    }
    
    years = c(2019,2020,2021,2022,2023)
    outcome_df=data.frame(no=1:5)
    for (i in 1:5){
      outcome_df$Year[i] = years[i]
      outcome_df$Total_exceed_treaty_limit_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
      outcome_df$Total_of_Ceded_Amount_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Ceded_Amount_loss"])
      outcome_df$Total_of_Retention_Loss[i] =sum(GEC[GEC$`Claim Year`==years[i],"Retention_loss"])
    }
    
    total = data.frame(Year=c(2019,2020,2021,2022,2023))
    
    total$net_premium =gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.)
    
    total$net_claim = retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.)-coverCB$cover
    
    total$loss_ratio_before = retentionsum$gincur/prem$gprem
    
    total$loss_ratio_after_facntreaty = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss)/gnpiT$sumGNPI
    
    total$loss_ratio_after_fanntreatynxol = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))
    
    total$loss_ratio_after_facntreatynxolnmotor = total$net_claim/total$net_premium
    
    # Before motor
    total$UWPBT_before_motor = (gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))-(retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem
    
    total$UWPAT_before_motor = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset_before_motor[i] = Ad_asset
      }else{
        total$Ad_asset_before_motor[i] = total$Ad_asset_before_motor[i+1]-total$UWPAT_before_motor[i+1]
      }
    }
    
    total$CAR_before_motor = total$Ad_asset_before_motor/(0.8*((gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))))
    
    
    # After motor
    total$UWPBT = total$net_premium-total$net_claim-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp-catastrophe_exp$exp
    total$UWPAT = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset[i] = Ad_asset
      }else{
        total$Ad_asset[i] = total$Ad_asset[i+1]-total$UWPAT[i+1]
      }
    }
    
    total$CAR = total$Ad_asset/(0.8*total$net_premium)
    return(total)
  }

}
export_year_with_catastrophe()
```
# best model
```{r}
# Based on optimization from above, sub in optimized parameter
if (TRUE){
  # best combination for treaty
  # 0.0025, 0.0005
  BestRL = 4
  BestRA = 20000000
  param = c(8,8,5,8,8)
  
  BestLayers <- data.frame(
    Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
    Deductible = c(2000000, 17000000, 0, 20000000, 100000000),
    Limit = c(20000000, 15000000, 20000000, 80000000, 30000000),
    Reinst = c(3,2,2,1,1)
  )
  
  BFloodRD = 1.2
  
  Blayers_motorD <- data.frame(
    Layers = c("Combined XOL L1","Combined XOL L2"),
    Rate = c(0.025, 0.01),
    Deductible = c(2000000, 7000000),
    Limit = c(5000000, 20000000),
    AnnualL = c(20000000,40000000),
    Reinst = c(4,2)
  )
}

orig_without_catastrophe = export_year()
orig_with_catastrophe = export_year_with_catastrophe()

best_only_treaty_optimized = export_year_with_catastrophe(Retention_lvl=BestRL,Retention_Amt=BestRA)
best_only_xol_optimized = export_year_with_catastrophe(layers=BestLayers)
best_overall = export_year_with_catastrophe(Retention_lvl=BestRL,Retention_Amt=BestRA,layers=BestLayers)

OResult = data.frame(no=1:5,type=c("orig_without_catastrophe","orig_with_catastrophe","best_only_treaty_optimized","best_only_xol_optimized","best_overall"))

OResult$profit[1] = sum(orig_without_catastrophe[,13])
OResult$profit[2] = sum(orig_with_catastrophe[,13])
OResult$profit[3] = sum(best_only_treaty_optimized[,13])
OResult$profit[4] = sum(best_only_xol_optimized[,13])
OResult$profit[5] = sum(best_overall[,13])

OResult$CAR[1] = mean(orig_without_catastrophe[,15])
OResult$CAR[2] = mean(orig_with_catastrophe[,15])
OResult$CAR[3] = mean(best_only_treaty_optimized[,15])
OResult$CAR[4] = mean(best_only_xol_optimized[,15])
OResult$CAR[5] = mean(best_overall[,15])

OResult$vcar[1] = var(orig_without_catastrophe[,15])
OResult$vcar[2] = var(orig_with_catastrophe[,15])
OResult$vcar[3] = var(best_only_treaty_optimized[,15])
OResult$vcar[4] = var(best_only_xol_optimized[,15])
OResult$vcar[5] = var(best_overall[,15])

colnames(OResult)[2]="Model"
OResult

# # [1] 3.737295e+07 1.747832e+00 4.896859e-02
# best(Retention_lvl=BestRL,Retention_Amt=BestRA)
# # [1] 7.417440e+07 1.648421e+00 2.690983e-02
# best(Retention_lvl=BestRL,Retention_Amt=BestRA,layers=BestLayers)
# # [1] 1.138931e+08 1.588138e+00 1.353792e-02 (only change nml1,nml2,wal1)

```
# ============================
# SCENARIO TESTING
# Predict 2024-2034
#  --------------------------------
# |Assumption:                     |
# | Net Premium ^ 10% (Property)   |
# | Net Premium ^ 20% (Motor)      |
# | Net Claim > Trend              |
#  --------------------------------
# TREND ANALYSIS
# 1a. Prepare dataframe
```{r}
if(TRUE){
  years = c(2019,2020,2021,2022,2023,seq(2024,2034,by=1))
  forecast = data.frame(no=1:16)
  for (i in 1:16){
    forecast$Year[i] = years[i]
    forecast$GPrem[i] = sum(gprem[gprem$`Commence Year`==years[i],"sum"])
    forecast$FPrem[i] = sum(fprem[fprem$Year==years[i],"sum"])
    forecast$GClaim[i] = sum(claim[claim$`Min Year`==years[i],"GROSS_INCURRED"])
    forecast$GSI[i] = sum(claim[claim$`Min Year`==years[i],"GROSS_SUM_INSURED"])
    forecast$FClaim[i] = sum(claim[claim$`Min Year`==years[i],"FAC_INCURRED"])
    forecast$MGPrem[i] = motor$GPrem[i]
    forecast$nclaim[i] = nrow(claim[claim$`Min Year`==years[i],])
    if(is.na(motor$GClaim[i])){
      forecast$MGClaim[i] = 0
    }else{
      forecast$MGClaim[i] = motor$GClaim[i]
    }
  }
}

# Forecast GPrem using assumption
for(i in 1:11){
  forecast$GPrem[i+5]= forecast$GPrem[i+4]*1.1
  forecast$FPrem[i+5]= forecast$FPrem[i+4]*1.1
  forecast$MGPrem[i+5]= forecast$MGPrem[i+4]*1.2
}
forecast
```

# 1a. Using moving average
```{r}
# install.packages("zoo")
library(zoo)

# Predicted GClaim
if(TRUE){
  PClaim <- forecast %>% 
  mutate(Moving_Avg_2 = rollmean(GClaim,k=2,fill=NA,align="right"),
         Moving_Avg_3 = rollmean(GClaim,k=3,fill=NA,align="right"),
         Moving_Avg_4 = rollmean(GClaim,k=4,fill=NA,align="right"),
         Moving_Avg_5 = rollmean(GClaim,k=5,fill=NA,align="right"),
         Moving_Avg_6 = rollmean(GClaim,k=6,fill=NA,align="right"),
         Moving_Avg_7 = rollmean(GClaim,k=7,fill=NA,align="right"),
         Moving_Avg_8 = rollmean(GClaim,k=8,fill=NA,align="right"))
  
  head(PClaim,10)
  
  PClaim$PClaim=0
  
  for(i in 1:nrow(PClaim)){
    if(PClaim$GClaim[i]!=0){
      PClaim$PClaim[i]=PClaim$GClaim[i]
    }else{
      year = PClaim[i,c("Moving_Avg_2","Moving_Avg_3","Moving_Avg_4","Moving_Avg_5","Moving_Avg_6","Moving_Avg_7","Moving_Avg_8")]
      year_extracted = c()
      for (j in year){
        if(j==0 | is.na(j)){
          next
        }else{
          year_extracted = append(year_extracted,j)
        }
      }
      PClaim$PClaim[i]=sum(year_extracted)/length(year_extracted)
    }
  }
  # PClaim[1:11,]
}

# Predicted FClaim
if(TRUE){
  FClaim <- forecast %>% 
  mutate(Moving_Avg_2 = rollmean(FClaim,k=2,fill=NA,align="right"),
         Moving_Avg_3 = rollmean(FClaim,k=3,fill=NA,align="right"),
         Moving_Avg_4 = rollmean(FClaim,k=4,fill=NA,align="right"),
         Moving_Avg_5 = rollmean(FClaim,k=5,fill=NA,align="right"),
         Moving_Avg_6 = rollmean(FClaim,k=6,fill=NA,align="right"),
         Moving_Avg_7 = rollmean(FClaim,k=7,fill=NA,align="right"),
         Moving_Avg_8 = rollmean(FClaim,k=8,fill=NA,align="right"))
  
  head(FClaim,10)
  
  FClaim$FClaim=0
  colnames(FClaim)
  
  for(i in 1:nrow(FClaim)){
    if(FClaim$FClaim[i]!=0){
      FClaim$FClaim[i]=FClaim$FClaim[i]
    }else{
      year = FClaim[i,c("Moving_Avg_2","Moving_Avg_3","Moving_Avg_4","Moving_Avg_5","Moving_Avg_6","Moving_Avg_7","Moving_Avg_8")]
      year_extracted = c()
      for (j in year){
        if(j==0 | is.na(j)){
          next
        }else{
          year_extracted = append(year_extracted,j)
        }
      }
      FClaim$FClaim[i]=sum(year_extracted)/length(year_extracted)
    }
  }
  # FClaim[1:11,]
}

# Predicted MGClaim
if(TRUE){
  MPClaim <- forecast %>% 
  mutate(Moving_Avg_2 = rollmean(MGClaim,k=2,fill=NA,align="right"),
         Moving_Avg_3 = rollmean(MGClaim,k=3,fill=NA,align="right"),
         Moving_Avg_4 = rollmean(MGClaim,k=4,fill=NA,align="right"),
         Moving_Avg_5 = rollmean(MGClaim,k=5,fill=NA,align="right"),
         Moving_Avg_6 = rollmean(MGClaim,k=6,fill=NA,align="right"),
         Moving_Avg_7 = rollmean(MGClaim,k=7,fill=NA,align="right"),
         Moving_Avg_8 = rollmean(MGClaim,k=8,fill=NA,align="right"))
  
  head(MPClaim,10)
  
  MPClaim$MPClaim=0
  
  for(i in 1:nrow(MPClaim)){
    if(MPClaim$MGClaim[i]!=0){
      MPClaim$MPClaim[i]=MPClaim$MGClaim[i]
    }else{
      year = MPClaim[i,c("Moving_Avg_2","Moving_Avg_3","Moving_Avg_4","Moving_Avg_5","Moving_Avg_6","Moving_Avg_7","Moving_Avg_8")]
      year_extracted = c()
      for (j in year){
        if(j==0 | is.na(j)){
          next
        }else{
          year_extracted = append(year_extracted,j)
        }
      }
      MPClaim$MPClaim[i]=sum(year_extracted)/length(year_extracted)
    }
  }
  MPClaim[1:11,]
}

# Predicted GSI
if(TRUE){
  PGSI <- forecast %>% 
  mutate(Moving_Avg_2 = rollmean(GSI,k=2,fill=NA,align="right"),
         Moving_Avg_3 = rollmean(GSI,k=3,fill=NA,align="right"),
         Moving_Avg_4 = rollmean(GSI,k=4,fill=NA,align="right"),
         Moving_Avg_5 = rollmean(GSI,k=5,fill=NA,align="right"),
         Moving_Avg_6 = rollmean(GSI,k=6,fill=NA,align="right"),
         Moving_Avg_7 = rollmean(GSI,k=7,fill=NA,align="right"),
         Moving_Avg_8 = rollmean(GSI,k=8,fill=NA,align="right"))
  
  head(PGSI,10)
  
  PGSI$PGSI=0
  
  for(i in 1:nrow(PGSI)){
    if(PGSI$GSI[i]!=0){
      PGSI$PGSI[i]=PGSI$GSI[i]
    }else{
      year = PGSI[i,c("Moving_Avg_2","Moving_Avg_3","Moving_Avg_4","Moving_Avg_5","Moving_Avg_6","Moving_Avg_7","Moving_Avg_8")]
      year_extracted = c()
      for (j in year){
        if(j==0 | is.na(j)){
          next
        }else{
          year_extracted = append(year_extracted,j)
        }
      }
      PGSI$PGSI[i]=sum(year_extracted)/length(year_extracted)
    }
  }
  PGSI[1:11,]
}

# Predicted 
if(TRUE){
  NClaim <- forecast %>% 
  mutate(Moving_Avg_2 = rollmean(nclaim,k=2,fill=NA,align="right"),
         Moving_Avg_3 = rollmean(nclaim,k=3,fill=NA,align="right"),
         Moving_Avg_4 = rollmean(nclaim,k=4,fill=NA,align="right"),
         Moving_Avg_5 = rollmean(nclaim,k=5,fill=NA,align="right"),
         Moving_Avg_6 = rollmean(nclaim,k=6,fill=NA,align="right"),
         Moving_Avg_7 = rollmean(nclaim,k=7,fill=NA,align="right"),
         Moving_Avg_8 = rollmean(nclaim,k=8,fill=NA,align="right"))
  
  head(NClaim,10)
  
  NClaim$NClaim=0
  
  for(i in 1:nrow(NClaim)){
    if(NClaim$nclaim[i]!=0){
      NClaim$PNClaim[i]=NClaim$nclaim[i]
    }else{
      year = NClaim[i,c("Moving_Avg_2","Moving_Avg_3","Moving_Avg_4","Moving_Avg_5","Moving_Avg_6","Moving_Avg_7","Moving_Avg_8")]
      year_extracted = c()
      for (j in year){
        if(j==0 | is.na(j)){
          next
        }else{
          year_extracted = append(year_extracted,j)
        }
      }
      NClaim$PNClaim[i]=sum(year_extracted)/length(year_extracted)
    }
  }
  NClaim[1:11,]
}

forecast$PGClaim = PClaim$PClaim
forecast$PFClaim = FClaim$FClaim
forecast$PMClaim = MPClaim$MPClaim
forecast$PGSI = PGSI$PGSI
forecast$NClaim = NClaim$PNClaim
forecast
PResult = forecast[,c(1:4,8,11:15)]
PResult
```
# 1b. Using RUniform to split claim to individual

# 2. Using moving avearge with CSM
```{r}
decomforecast <- read_excel(General,sheet="Claim forecasting data")
head(decomforecast)
decomforecast
ycma1 <-decomforecast[, c("Year", "Y/CMA")]
ycma2<-head(ycma1,20)

decomforecast2 <- data.frame("y/cma"= ycma2$`Y/CMA`)
decomforecast2<-apply(decomforecast2, 2, as.numeric);decomforecast2
y.cma_matrix <- matrix(decomforecast2, ncol = 4,byrow = TRUE);y.cma_matrix
y.cma_df <- as.data.frame(y.cma_matrix)
y.cma_df
rownames(y.cma_df) <- c("2019", "2020", "2021", "2022", "2023")
colnames(y.cma_df) <- c("Q1", "Q2", "Q3", "Q4")
y.cma_df["TOTAL", ] <- colSums(y.cma_df, na.rm = TRUE)
y.cma_df["Avg", ] <- colSums(y.cma_df[1:5, ], na.rm = TRUE) / 4
y.cma_df["Adjusted Factor", ]<-(4-(y.cma_df[7,1]+y.cma_df[7,2]+y.cma_df[7,3]+y.cma_df[7,4]))/4
y.cma_df["Adjusted Seasonal variation", ]<- y.cma_df[7,]+y.cma_df[8,]
y.cma_df

#CMA as trend
#calculated slope
slope<-as.numeric(decomforecast[18,6]-decomforecast[3,6])/(18-3)
slope
forecast_val<-as.numeric(c((decomforecast[18,6]+ 3*(slope)),(decomforecast[18,6]+ 4*(slope)),(decomforecast[18,6]+ 5*(slope)),(decomforecast[18,6]+ 6*(slope))))
forecast_val

#Adjusted variation
adj_var<-as.numeric(c(y.cma_df[9,1],y.cma_df[9,2],y.cma_df[9,3],y.cma_df[9,4]))
adj_var

# 2024
Claim2024<-data.frame("Forecast"=forecast_val,"adjusted seasonal variation"=adj_var)
Claim2024[,"Forecast Value"]<-Claim2024[,1]*Claim2024[,2]
rownames(Claim2024) <- c("2024Q1", "2024Q2", "2024Q3", "2024Q4")
Claim2024
Total_Claim2024<-sum(Claim2024$`Forecast Value`);Total_Claim2024
```


# ----
# Sub Predicted GClaim and GPrem into model with best parameter
```{r}
# Tune (Sub in best parameter)
if (TRUE){
  Retention_lvlD = 9
  
  Retention_AmtD = 30000000
  
  layers_infoD <- data.frame(
      Layers = c("NonMarineLayer1", "NonMarineLayer2", "WholeAccLayer1", "WholeAccLayer2", "WholeAccLayer3"),
      Rate = c(0.0185, 0.01, 0.008, 0.008, 0.003),
      Deductible = c(5000000, 20000000, 0, 20000000, 100000000),
      Limit = c(15000000, 10000000, 20000000, 80000000, 30000000),
      Reinst = c(3,2,2,1,1)
  )
  
  FloodRD = 1.2
  
  layers_motorD <- data.frame(
    Layers = c("Combined XOL L1","Combined XOL L2"),
    Rate = c(0.025, 0.01),
    Deductible = c(2000000, 7000000),
    Limit = c(5000000, 20000000),
    AnnualL = c(20000000,40000000),
    Reinst = c(4,2)
  )
}

# Forecast Data
if(TRUE){
    PResult$after_fac_incurred = PResult$GROSS_INCURRED-PResult$FAC_INCCURED
}

# Modified function (per year data instead of per event)
Forecast <- function(Retention_lvl=Retention_lvlD,Retention_Amt=Retention_AmtD,layers=layers_infoD,FloodR=FloodRD,layersM=layers_motorD){
  
  # Treaty Parameter Tuning
  if (TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
  }
  
  #Treaty Retention
  if(TRUE){
    Retention=Retention_Amt
    noline = Retention_lvl
    Surplus= noline*Retention
    Capacity= Retention + Surplus
    
    #RETENTION
    # calculate facultative ratio
    PResult$Facultative_Ratio <- (PResult$after_fac_incurred / PResult$GROSS_INCURRED)
    
    # calculate gross_sum_insurred after facultative
    PResult$Other_Reinsurance <- PResult$Facultative_Ratio * PResult$GROSS_SUM_INSURED
    
    # Calculate Retention Ratio
    Retention_Ratio <- ifelse(
      (Retention / PResult$Other_Reinsurance + pmax(0, PResult$Other_Reinsurance - Capacity) / PResult$Other_Reinsurance) >= 1,
      1,
      Retention / PResult$Other_Reinsurance + pmax(0, PResult$Other_Reinsurance - Capacity) / PResult$Other_Reinsurance
    )
    
    # Add a new column named "Retention Ratio" to the PResult dataframe
    PResult$Retention_Ratio <- Retention_Ratio
    
    # calculate the Retention_sum insured
    PResult$Retention_sum_insured<-PResult$Other_Reinsurance*PResult$Retention_Ratio
    
    # calculate the Retention_loss
    PResult$Retention_loss<-PResult$after_fac_incurred*PResult$Retention_Ratio
    
    
    
    #CEDED AMOUNT
    #calculate ceded amount ratio
    PResult$Ceded_Amount_Ratio<- 1-PResult$Retention_Ratio
    
    #calculate ceded amount_sum insured
    PResult$Ceded_Amount_sum_insured<- PResult$Other_Reinsurance*PResult$Ceded_Amount_Ratio
    
    #calculate ceded amount loss
    PResult$Ceded_Amount_loss<- PResult$after_fac_incurred*PResult$Ceded_Amount_Ratio
    
    
    
    #EXCEED TREATY LIMIT
    PResult$Exceed_treaty_limit <- ifelse(PResult$Other_Reinsurance > Capacity, PResult$Other_Reinsurance - Capacity, 0)
    
    #ratio of exceed treaty limit in retention
    PResult$Exceed_treaty_limit_ratio <- PResult$Exceed_treaty_limit/PResult$Retention_sum_insured
    
    #Exceed SUM_INCURRED
    PResult$Exceed_treaty_limit_sum_incurred <- PResult$Exceed_treaty_limit_ratio*PResult$after_fac_incurred
  }
  
  # Treaty Calculation
  if(TRUE){
    library(dplyr)
    Treaty <- function(year){
      
      # Calculate facultative ratio
      claim2019_df$Facultative_Ratio <- (claim2019_df$after_fac_incurred / claim2019_df$GROSS_INCURRED)
      
      # Calculate gross_sum_insured after facultative
      claim2019_df$Other_Reinsurance <- claim2019_df$Facultative_Ratio * claim2019_df$GROSS_SUM_INSURED
      
      # Calculate Retention Ratio
      Retention_Ratio <- ifelse(
        (Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance) >= 1,
        1,
        Retention / claim2019_df$Other_Reinsurance + pmax(0, claim2019_df$Other_Reinsurance - Capacity) / claim2019_df$Other_Reinsurance
      )
      
      # Add a new column named "Retention Ratio" to the claim2019_df dataframe
      claim2019_df$Retention_Ratio <- Retention_Ratio
      
      # Calculate the Retention_sum_insured
      claim2019_df$Retention_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Retention_Ratio
      
      # Calculate the Retention_loss
      claim2019_df$Retention_loss <- claim2019_df$after_fac_incurred * claim2019_df$Retention_Ratio
      
      # Calculate ceded amount ratio
      claim2019_df$Ceded_Amount_Ratio <- 1 - claim2019_df$Retention_Ratio
      
      # Calculate ceded amount_sum insured
      claim2019_df$Ceded_Amount_sum_insured <- claim2019_df$Other_Reinsurance * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate ceded amount loss
      claim2019_df$Ceded_Amount_loss <- claim2019_df$after_fac_incurred * claim2019_df$Ceded_Amount_Ratio
      
      # Calculate Exceed Treaty Limit
      claim2019_df$Exceed_treaty_limit <- ifelse(claim2019_df$Other_Reinsurance > Capacity, claim2019_df$Other_Reinsurance - Capacity, 0)
      
      # Calculate ratio of exceed treaty limit in retention
      claim2019_df$Exceed_treaty_limit_ratio <- claim2019_df$Exceed_treaty_limit / claim2019_df$Retention_sum_insured
      
      # Calculate Exceed SUM_INCURRED
      claim2019_df$Exceed_treaty_limit_sum_incurred <- claim2019_df$Exceed_treaty_limit_ratio * claim2019_df$after_fac_incurred
      
      # Filter the dataframe for Event codes E001, E002, and E006
      filtered_df2019 <- claim2019_df[claim2019_df$EVENT_CODE %in% unique(claim2019$EVENT_CODE)[!is.na(unique(claim2019$EVENT_CODE))], ]
      
      for (i in 1:length(filtered_df2019$EVENT_CODE)){
        filtered_df2019$Date[i] = claim[which(claim$EVENT_CODE==filtered_df2019$EVENT_CODE[i]),"CLAIM_OCCURRENCE_DT"][[1]][1]
        filtered_df2019$`Claim Year`[i] = year
      }
      colnames(filtered_df2019)[16] = "Date"
      return(filtered_df2019)
    }
    
    NaEC = claim[is.na(claim$EVENT_CODE),][,c(11,16,21,14,19,20,22,23,24,25,26,27,28,29,30,4,5)]
    colnames(NaEC)[16] = "Date"
    
    TA = data.frame()
    Year = c(2019,2020,2021,2022,2023)
    for (i in 1:5){
      ans = Treaty(Year[i])
      TA = rbind(TA,ans)
    }
    GEC = rbind(TA,NaEC)
    # TA
    # GEC[which(NaEC$EVENT_CODE=="E006"),]
    # GEC
  }
  
  # Treaty Premium
  if(TRUE){
    sum_insured = c(0,100001,250001,500001,750001,1000001,2500001,5000001,7500001,10000001,12000001,14000001,16000001,18000001,20000001,25000001,30000001,40000001,50000001,70000001,100000001,200000001,300000001,400000001,500000001,1000000001)
    prem_avr = c(50000.5,175000.5,375000.5,625000.5,875000.5,1750000.5,3750001,6250001,8750001,11000001,13000001,15000001,17000001,19000001,22500001,27500001,35000001,45000001,60000001,85000001,150000001,250000001,350000001,450000001,750000001,1000000001)
    prem_data = data.frame(sum_insured=sum_insured,prem_avr=prem_avr,retention_ratio=rep(26,1))
    
    retention_ratio <- function(prem){
      if((Retention/prem+max(0,(prem-Capacity)/prem))>=1){
        return (1)
      }else{
        return(Retention/prem+max(0,(prem-Capacity)/prem))
      }
    }
    
    index = 1
    for (i in prem_data$prem_avr){
      prem_data[index,3] = retention_ratio(i)
      index = index+1
    }
    
    retention_prem = gprem
    retention_prem[,28] = retention_prem[,28]-fprem[,28]
    retention_prem[,29] = retention_prem[,29]-fprem[,29]
    retention_prem[,30] = retention_prem[,30]-fprem[,30]

    index = 1
    for (i in colnames(retention_prem)[5:30]){
      for (j in 1:nrow(retention_prem[,index+4])){
        retention_prem[j,index+4] = retention_prem[j,index+4]*prem_data[index,3]
        # print(j)
      }
      # print("out")
      index = index +1
    }
    # print(retention_prem[,29])
    
    for (i in 1:nrow(retention_prem)){
      retention_prem[i,"sum"]= sum(retention_prem[i,5:30])
    }
    
    gnpiT = data.frame(Year=c(2019,2020,2021,2022,2023))
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGNPI[index] = sum(retention_prem[retention_prem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumGprem[index] = sum(gprem[gprem$`Commence Year`==i,'sum'])
      index = index +1
    }
    index = 1
    for (i in gnpiT[,1]){
      gnpiT$sumFprem[index] = sum(fprem[fprem$`Year`==i,'sum'])
      index = index +1
    }
  }
  
  # XOL Parameter Tuning
  if (TRUE){
    layers_info = layers
  
    Flood_Rate = FloodR
    no.layer = 5
    
    gnpi <- data.frame(
      Year = c(2019,2020,2021,2022,2023),
      GNPI = gnpiT$sumGNPI
    )
  }
  
  # XOL Calculation
  if (TRUE){
    GECK <- GEC[order(GEC$Date,decreasing=FALSE),]
Result <- data.frame("Year","TotalD","TotalLR","TotalRPrem","TotalPrem")
    
    for (i in 1:nrow(GECK)){
      if(GECK$EVENT_CODE[i] %in% c("E006", "E009", "E012", "E020", "E021", "E022", "E023", "E025", "E026")){
        GECK$Type[i]="Flood"
      }else{
        GECK$Type[i]="Normal"
      }
    }
    
    for (i in 1:5){
      year <- gnpi$Year[i]
      gnpi_year <- gnpi$GNPI[i]
      
      # Group as year
      GEC_Year = GECK[GECK$`Claim Year`==year,]
      colnames(GEC_Year)[15] = "Loss"
      GEC_Year = GEC_Year[GEC_Year$Loss>layers_info$Deductible[1],]
      
      # If that year don't have, then skip
      if(nrow(GEC_Year)==0){
        total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
        total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
        total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
        total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
        
        Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
        next
      }
      
      # RUN every claim
      for(k in 1:nrow(GEC_Year)){
        loss = GEC_Year$Loss[k]
        
        #NML1
        if(loss<=layers_info$Deductible[1]){
          GEC_Year$NML1[k]=loss
        }else{
          GEC_Year$NML1[k]=layers_info$Deductible[1]
        }
        
        #LAR NML1
        GEC_Year$LARNML1[k] = min(min(loss-GEC_Year$NML1[k],layers_info$Limit[1]),layers_info$Limit[1]*(layers_info$Reinst[1]+1))
        
        #Cover Remaining NML1
        GEC_Year$CoverNML1[k] = layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$LARNML1[k]
        
        
        #Reinstated Premium 1
        if(GEC_Year$CoverNML1[k]<layers_info$Limit[1]){
          GEC_Year$PremNML1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML1[k]= Flood_Rate*layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }else{
            GEC_Year$PremNML1[k]= layers_info$Rate[1]*gnpi_year*(layers_info$Limit[1]*(layers_info$Reinst[1]+1)-GEC_Year$CoverNML1[k])/layers_info$Limit[1]
          }
        }
        
        #NML2
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]<=layers_info$Deductible[2]){
          GEC_Year$NML2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]
        }else{
          GEC_Year$NML2[k]=layers_info$Deductible[2]
        }
    
        #LAR NML2
        GEC_Year$LARNML2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k],layers_info$Limit[2]),layers_info$Limit[2]*(layers_info$Reinst[2]+1))
    
        #Cover Remaining NML2
        GEC_Year$CoverNML2[k] = layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$LARNML2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverNML2[k]<layers_info$Limit[2]){
          GEC_Year$PremNML2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremNML2[k]= Flood_Rate*layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }else{
            GEC_Year$PremNML2[k]= layers_info$Rate[2]*gnpi_year*(layers_info$Limit[2]*(layers_info$Reinst[2]+1)-GEC_Year$CoverNML2[k])/layers_info$Limit[2]
          }
        }
        
        sym = 3
        
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]<=layers_info$Deductible[sym]){
          GEC_Year$WAL1[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]
        }else{
          GEC_Year$WAL1[k]=layers_info$Deductible[sym]
        }
    
        #LAR WAL1
        GEC_Year$LARWAL1[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k],layers_info$Limit[sym]),layers_info$Limit[sym]*(layers_info$Reinst[sym]+1))
    
        #Cover Remaining WAL1
        GEC_Year$CoverWAL1[k] = layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$LARWAL1[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL1[k]<layers_info$Limit[sym]){
          GEC_Year$PremWAL1[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL1[k]= Flood_Rate*layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }else{
            GEC_Year$PremWAL1[k]= layers_info$Rate[sym]*gnpi_year*(layers_info$Limit[sym]*(layers_info$Reinst[sym]+1)-GEC_Year$CoverWAL1[k])/layers_info$Limit[sym]
          }
        }
        
        
        sym2 = 4
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL2[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]
        }else{
          GEC_Year$WAL2[k]=layers_info$Deductible[sym2]
        }
        
        #LAR WAL2
        GEC_Year$LARWAL2[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL2[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL2[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL2[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL2[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL2[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL2[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL2[k])/layers_info$Limit[sym2]
          }
        }
        
        sym2 = 5
        #WAL1
        if(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]<=layers_info$Deductible[sym2]){
          GEC_Year$WAL3[k]=loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]
        }else{
          GEC_Year$WAL3[k]=layers_info$Deductible[sym2]
        }
        
        #LAR wal3
        GEC_Year$LARWAL3[k] = min(min(loss-GEC_Year$NML1[k]-GEC_Year$LARNML1[k]-GEC_Year$NML2[k]-GEC_Year$LARNML2[k]-GEC_Year$WAL1[k]-GEC_Year$LARWAL1[k]-GEC_Year$WAL2[k]-GEC_Year$LARWAL2[k]-GEC_Year$WAL3[k],layers_info$Limit[sym2]),layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1))
    
        #Cover Remaining WAL2
        GEC_Year$CoverWAL3[k] = layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$LARWAL3[k]
    
        #Reinstated Premium 2
        if(GEC_Year$CoverWAL3[k]<layers_info$Limit[sym2]){
          GEC_Year$PremWAL3[k]= 0
        }else{
          if(GEC_Year$Type[k]=="Flood"){
           GEC_Year$PremWAL3[k]= Flood_Rate*layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }else{
            GEC_Year$PremWAL3[k]= layers_info$Rate[sym2]*gnpi_year*(layers_info$Limit[sym2]*(layers_info$Reinst[sym2]+1)-GEC_Year$CoverWAL3[k])/layers_info$Limit[sym2]
          }
        }
        
        
        
      } 
      
      total_loss_recoverable_sum = sum(GEC_Year$LARNML1)+sum(GEC_Year$LARNML2)+sum(GEC_Year$LARWAL1)+sum(GEC_Year$LARWAL2)+sum(GEC_Year$LARWAL3)
      total_deductible = sum(GEC_Year$NML1)+sum(GEC_Year$NML2)+sum(GEC_Year$WAL1)+sum(GEC_Year$WAL2)+sum(GEC_Year$WAL3)
      total_rprem = sum(GEC_Year$PremNML1)+sum(GEC_Year$PremNML2)+sum(GEC_Year$PremWAL1)+sum(GEC_Year$PremWAL2)+sum(GEC_Year$PremWAL3)
      total_tprem = sum(layers_info$Rate)*gnpi_year+total_rprem
      
      Result <- rbind(Result,c(year,total_deductible,total_loss_recoverable_sum,total_rprem,total_tprem))
    }
    
    Result <- Result[2:6,]
  }
  
  # Data for motor (Given)
  if (TRUE){
    motor <- data.frame(
    Year=c(2019,2020,2021,2022,2023),
    GPrem = c(60513120,78178940,89592170,100541210,111231110),
    GClaim = c(43039442.23848,61050872.39328,66408905.885252,77739468.9841,87244254.605832),
    GCom = 0,
    MExp = c(6724465.998192,9783422.002116,10134755.86257,12077422.364161,13041985.0179209)
  )
  }
  
  # XOL for Motor
  if (TRUE){
    layers_motor = layersM
    
    ResultM <- data.frame("Year","TotalD","TotalLR","TotalPrem")
    
    for (i in 1:5){
      year <- motor$Year[i]
      gnpi_year <- motor$GPrem[i]
      
      motor_Year = motor_claim[motor_claim$`Accident Year`==year,]
      motor_Year = motor_Year[motor_Year$GROSS_INCURRED>2000000,]
      motor_Year$L1 = 0
      motor_Year$LARL1 = 0
      motor_Year$CoverL1 = 0
      motor_Year$L2 = 0
      motor_Year$LARL2 = 0
      motor_Year$CoverL2 = 0
      
      if(nrow(motor_Year)==0){
        total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
        total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
        total_tpremM = sum(layers_motor$Rate)*gnpi_year
        ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
        next
      }
      # RUN every claim
      for(k in 1:nrow(motor_Year)){
        loss = motor_Year$GROSS_INCURRED[k]
        
        #L1
        if(loss<=layers_motor$Deductible[1]){
          motor_Year$L1[k]=loss
        }else{
          motor_Year$L1[k]=layers_motor$Deductible[1]
        }
        
        #LAR L1
        motor_Year$LARL1[k] = min(min(loss-motor_Year$L1[k],layers_motor$Limit[1]),layers_motor$Limit[1]*(layers_motor$Reinst[1]))
        
        #Cover Remaining NML1
        if(k==1){
          motor_Year$CoverL1[k] = layers_motor$Limit[1]*layers_motor$Reinst[1]-motor_Year$LARL1[k]
        }else{
          motor_Year$CoverL1[k] = motor_Year$CoverL1[k-1]-motor_Year$LARL1[k]
        }
        
        #L2
        if(loss-motor_Year$L1[k]-motor_Year$LARL1[k]<=layers_motor$Deductible[2]){
          motor_Year$L2[k]=loss-motor_Year$L1[k]-motor_Year$LARL1[k]
        }else{
          motor_Year$L2[k]=layers_info$Deductible[2]
        }
        
        #LAR L2
        motor_Year$LARL2[k] = min(min(loss-motor_Year$L1[k]-motor_Year$LARL1[k]-motor_Year$L2[k],layers_motor$Limit[2]),layers_motor$Limit[2]*(layers_motor$Reinst[2]))
        
        #Cover Remaining NML2
        if(k==1){
          motor_Year$CoverL2[k] = layers_motor$Limit[2]*layers_motor$Reinst[2]-motor_Year$LARL2[k]
        }else{
          motor_Year$CoverL2[k] = motor_Year$CoverL2[k-1]-motor_Year$LARL2[k]
        }
        
      }
      total_loss_recoverable_sumM = sum(motor_Year$LARL1)+sum(motor_Year$LARL2)
      total_deductibleM = sum(motor_Year$L1)+sum(motor_Year$L2)
      total_tpremM = sum(layers_motor$Rate)*gnpi_year
      ResultM <- rbind(ResultM,c(year,total_deductibleM,total_loss_recoverable_sumM,total_tpremM))
    }
    
    ResultM <- ResultM[2:6,]
    
    ResultM$GPrem = motor$GPrem
    ResultM$GClaim = motor$GClaim
    ResultM$GCom = 0
    ResultM$MExp = motor$MExp
    
    for (i in 1:5){
      ResultM$GIncur[i] = sum(motor_claim[motor_claim$`Accident Year`==motor$Year[i],"GROSS_INCURRED"])
    }
  }
  
  # Combine all result
  if (TRUE){
    retentionsum = data.frame(sum=c(1,2,3,4,5))
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$gincur[index] = sum(claim[claim$`Min Year`==i,'GROSS_INCURRED'])
      index = index +1
    }
    
    index = 1
    for (i in c(2019,2020,2021,2022,2023)){
      retentionsum$fincur[index] = sum(claim[claim$`Min Year`==i,'FAC_INCURRED'])
      index = index +1
    }
    
    years = c(2019,2020,2021,2022,2023)
    outcome_df=data.frame(no=1:5)
    for (i in 1:5){
      outcome_df$Year[i] = years[i]
      outcome_df$Total_exceed_treaty_limit_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Exceed_treaty_limit"])
      outcome_df$Total_of_Ceded_Amount_loss[i] = sum(GEC[GEC$`Claim Year`==years[i],"Ceded_Amount_loss"])
      outcome_df$Total_of_Retention_Loss[i] =sum(GEC[GEC$`Claim Year`==years[i],"Retention_loss"])
    }
    
    total = data.frame(Year=c(2019,2020,2021,2022,2023))
    
    total$net_premium =gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.)-as.numeric(ResultM$X.TotalPrem.)
    
    total$net_claim = retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.)-as.numeric(ResultM$X.TotalLR.)
    
    total$loss_ratio_before = retentionsum$gincur/prem$gprem
    
    total$loss_ratio_after_facntreaty = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss)/gnpiT$sumGNPI
    
    total$loss_ratio_after_fanntreatynxol = (retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))/(gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))
    
    total$loss_ratio_after_facntreatynxolnmotor = total$net_claim/total$net_premium
    
    # Before motor
    total$UWPBT_before_motor = (gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))-(retentionsum$gincur-retentionsum$fincur-outcome_df$Total_of_Ceded_Amount_loss-as.numeric(Result$X.TotalLR.))-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem
    
    total$UWPAT_before_motor = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset_before_motor[i] = Ad_asset
      }else{
        total$Ad_asset_before_motor[i] = total$Ad_asset_before_motor[i+1]-total$UWPAT_before_motor[i+1]
      }
    }
    
    total$CAR_before_motor = total$Ad_asset_before_motor/(0.8*((gnpiT$sumGNPI-as.numeric(Result$X.TotalPrem.))))
    
    
    # After motor
    total$UWPBT = total$net_premium-total$net_claim-(0.2*gnpiT$sumGprem+0.05*retentionsum$fincur)-0.15*gnpiT$sumGprem-ResultM$MExp
    total$UWPAT = (1-0.24)*total$UWPBT
    
    Ad_asset = 500000000
    for(i in c(5,4,3,2,1)){
      if(i==5){
        total$Ad_asset[i] = Ad_asset
      }else{
        total$Ad_asset[i] = total$Ad_asset[i+1]-total$UWPAT[i+1]
      }
    }
    
    total$CAR = total$Ad_asset/(0.8*total$net_premium)
    return(c(sum(total$UWPAT),mean(total$CAR),var(total$CAR)))
  }

}
print(best())
```